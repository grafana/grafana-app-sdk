package main

import (
	"bytes"
	"context"
	"fmt"
	"net/http"
	"os"

	"github.com/grafana/grafana-app-sdk/apiserver"
	corev1 "github.com/grafana/grafana-app-sdk/examples/apiserver/apis/core/v1"
	corev2 "github.com/grafana/grafana-app-sdk/examples/apiserver/apis/core/v2"
	"github.com/grafana/grafana-app-sdk/k8s"
	"github.com/grafana/grafana-app-sdk/operator"
	"github.com/grafana/grafana-app-sdk/resource"
	"github.com/grafana/grafana-app-sdk/simple"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"k8s.io/component-base/cli"
	"k8s.io/kube-openapi/pkg/common"
	"k8s.io/kube-openapi/pkg/validation/spec"
)

func main() {
	// For each resource we want to serve from the API server, we need to create an apiserver.Resource
	// An apiserver.Resource MUST contain a Kind and GetOpenAPIDefinitions, both of which are generated by the codegen.
	// Optionally, an apiserver.Resource can contain additional Subresources that have HTTP handlers,
	// Admission control validation and mutation logic, and a Reconciler to watch events for the Kind.

	// Create an API Server Resource for the v1 ExternalName
	externalNameV1 := apiserver.Resource{
		Kind:                  corev1.ExternalNameKind(),
		GetOpenAPIDefinitions: corev1.GetOpenAPIDefinitions,
		// Example "foo" subresource that just prints out some JSON payload
		Subresources: []apiserver.SubresourceRoute{{
			Path:    "foo",
			Handler: handleFooSubresource,
			// FIXME: Currently this is not registered with the APIServer in any way
			OpenAPISpec: fooSubresourceOpenAPI,
		}},
		Mutator:   &mutatingAdmissionController{},
		Validator: &validatingAdmissionController{},
		// Reconciler to run for this kind. We use simple.ResourceReconcilerFunc to wrap our simple reconciler
		// inside a no-op instantiation function, since we don't need the ClientGenerator or OptionsGetter in our reconciler
		Reconciler: simple.ResourceReconcilerFunc(&simple.Reconciler{
			ReconcileFunc: reconcileV1ExternalNames,
		}),
		Converter: &apiserver.TypedResourceConverter[*corev2.ExternalName, *corev1.ExternalName]{
			FromInternalFunc: func(src *corev2.ExternalName, dst *corev1.ExternalName) error {
				src.ObjectMeta.DeepCopyInto(&dst.ObjectMeta)
				dst.Spec.Host = src.Spec.Host
				dst.SetGroupVersionKind(schema.GroupVersionKind{
					Group:   corev1.ExternalNameKind().Group(),
					Version: corev1.ExternalNameKind().Version(),
					Kind:    corev1.ExternalNameKind().Kind(),
				})
				return nil
			},
			ToInternalFunc: func(src *corev1.ExternalName, dst *corev2.ExternalName) error {
				src.ObjectMeta.DeepCopyInto(&dst.ObjectMeta)
				dst.Spec.Host = src.Spec.Host
				dst.Spec.OtherData = "upconverted data"
				dst.SetGroupVersionKind(schema.GroupVersionKind{
					Group:   corev1.ExternalNameKind().Group(),
					Version: corev1.ExternalNameKind().Version(),
					Kind:    corev1.ExternalNameKind().Kind(),
				})
				return nil
			},
		},
	}
	// Create an API Server Resource for the v2 ExternalName
	externalNameV2 := apiserver.Resource{
		Kind:                  corev2.ExternalNameKind(),
		GetOpenAPIDefinitions: corev2.GetOpenAPIDefinitions,
		// No Reconciler for this one, because we'd get duplicate events (one each for v1 and v2 of the kind)
	}
	// v1 TestKind
	testKindV1 := apiserver.Resource{
		Kind:                  corev1.TestKindKind(),
		GetOpenAPIDefinitions: corev1.GetOpenAPIDefinitions,
	}

	// apiserver.Resource items must be added to an apiserver.ResourceGroup.
	// Currently, there is no validation that the Name in the ResourceGroup matches the Group in each added Resource
	// TODO: have a Validate() method on ResourceGroup to check that?
	resourceGroup := apiserver.NewResourceGroup(corev1.ExternalNameKind().Group(), []apiserver.Resource{externalNameV1, externalNameV2, testKindV1})

	// APIServerOptions is used to create the API server from one or more ResourceGroups.
	// TODO: this will be expanded upon
	o := simple.NewAPIServerOptions([]apiserver.ResourceGroup{*resourceGroup}, os.Stdout, os.Stderr)
	o.RecommendedOptions.Authorization = nil
	o.RecommendedOptions.Authentication = nil
	o.RecommendedOptions.CoreAPI = nil

	ch := make(chan struct{})
	cmd := simple.NewCommandStartAPIServer(o, ch)

	code := cli.Run(cmd)
	os.Exit(code)
}

var _ resource.MutatingAdmissionController = &mutatingAdmissionController{}

type mutatingAdmissionController struct{}

func (m *mutatingAdmissionController) Mutate(ctx context.Context, request *resource.AdmissionRequest) (*resource.MutatingResponse, error) {
	obj := request.Object
	obj.SetAnnotations(map[string]string{"mutated": "true"})
	return &resource.MutatingResponse{
		UpdatedObject: obj,
	}, nil
}

var _ resource.ValidatingAdmissionController = &validatingAdmissionController{}

type validatingAdmissionController struct{}

func (v *validatingAdmissionController) Validate(ctx context.Context, request *resource.AdmissionRequest) error {
	if request.Object.GetName() == "invalid" {
		return k8s.NewAdmissionError(fmt.Errorf("object name cannot be 'invalid'"), http.StatusBadRequest, "invalid name")
	}
	return nil
}

func reconcileV1ExternalNames(ctx context.Context, request operator.ReconcileRequest) (operator.ReconcileResult, error) {
	fmt.Printf("Received %s event for %s\n", operator.ResourceActionFromReconcileAction(request.Action), request.Object.GetName())
	cast, ok := request.Object.(*corev1.ExternalName)
	if !ok {
		return operator.ReconcileResult{}, fmt.Errorf("reconcile object is not *corev1.ExternalName (gvk=%s)", request.Object.GroupVersionKind().String())
	}
	fmt.Printf("ResourceVersion: %s, Host: %s\n", cast.GetResourceVersion(), cast.Spec.Host)
	return operator.ReconcileResult{}, nil
}

func handleFooSubresource(w http.ResponseWriter, r *http.Request, identifier resource.Identifier) {
	fmt.Println("Called foo subresource for externalName: ", identifier)
	w.Write([]byte(`{"notright":2}`))
}

func fooSubresourceOpenAPI(callback common.ReferenceCallback) map[string]common.OpenAPIDefinition {
	return map[string]common.OpenAPIDefinition{
		"github.com/grafana/grafana-app-sdk/examples/apiserver/apis/core/v1.ExternalNameFoo": common.OpenAPIDefinition{
			Schema: spec.Schema{
				SchemaProps: spec.SchemaProps{
					Description: "ExternalNameFoo defines model for ExternalNameFoo.",
					Type:        []string{"object"},
					Properties: map[string]spec.Schema{
						"foo": {
							SchemaProps: spec.SchemaProps{
								Default: "",
								Type:    []string{"string"},
								Format:  "",
							},
						},
					},
					Required: []string{"foo"},
				},
			},
		},
	}
}

type Converter struct {
}

func (c *Converter) Convert(obj k8s.RawKind, targetAPIVersion string) ([]byte, error) {
	fmt.Println("Convert " + obj.APIVersion + " to " + targetAPIVersion)
	var target resource.Object
	ver := obj.Version
	switch targetAPIVersion {
	case "core.grafana.internal/v1":
		target = &corev1.ExternalName{}
		ver = "v1"
	case "core.grafana.internal/v2":
		target = &corev2.ExternalName{}
		ver = "v2"
	}
	codec := corev1.ExternalNameJSONCodec{}
	err := codec.Read(bytes.NewReader(obj.Raw), target)
	if err != nil {
		return nil, err
	}
	target.SetGroupVersionKind(schema.GroupVersionKind{
		Kind:    obj.Kind,
		Group:   obj.Group,
		Version: ver,
	})
	buf := bytes.Buffer{}
	err = codec.Write(&buf, target)
	return buf.Bytes(), err
}
