
# version_settings() enforces a minimum Tilt version
# https://docs.tilt.dev/api.html#api.version_settings
version_settings(constraint='>=0.22.2')

# Load Helm extension for helm_repo and helm_resource functions
load('ext://helm_resource', 'helm_resource', 'helm_repo')

# Configure local registry
default_registry('localhost:5000')

# Load operator image name from config.yaml or config.json
operator_image = ''
if os.path.exists('config.json'):
    config = read_json('config.json')
    operator_image = config.get('operatorImage', '')
elif os.path.exists('config.yaml'):
    config = read_yaml('config.yaml')
    operator_image = config.get('operatorImage', '')

# Build and push the operator image to the local registry if operatorImage is set
if operator_image:
    docker_build('localhost/'+operator_image, 
                 context='../',
                 dockerfile='../cmd/operator/Dockerfile')

# Ingress
# Check if an ingress controller already exists (e.g., traefik in k3d)
# Only deploy nginx-ingress if no ingress controller is found
# Check for common ingress controllers: traefik (k3d), nginx-ingress, or any IngressClass
_ingress_check_cmd = 'kubectl get ingressclass -o name 2>/dev/null | head -1 || kubectl get deployment traefik -n kube-system -o name 2>/dev/null | head -1 || kubectl get deployment ingress-nginx-controller -n ingress-nginx -o name 2>/dev/null | head -1 || echo ""'
_ingress_check_result = str(local(_ingress_check_cmd, quiet=True))
_has_ingress = _ingress_check_result and _ingress_check_result.strip() != ""

if not _has_ingress:
    # Add the ingress-nginx chart repository
    helm_repo(
        'ingress-nginx-repo',
        'https://kubernetes.github.io/ingress-nginx',
    )

    # Create the ingress-nginx namespace if it doesn't exist
    local('kubectl get ns ingress-nginx || kubectl create ns ingress-nginx')

    # Check if ingress-ready label exists on any node (for kind clusters)
    _node_check = str(local('kubectl get nodes -l ingress-ready=true -o name 2>/dev/null | head -1 || echo ""', quiet=True))
    _has_ingress_ready_node = _node_check and _node_check.strip() != ""
    
    # Build helm flags
    _helm_flags = [
        '--set', 'controller.hostPort.enabled=true',
        '--set', 'controller.hostPort.ports.http=80',
        '--set', 'controller.hostPort.ports.https=443',
        '--set', 'controller.service.type=NodePort',
        '--set', 'controller.replicaCount=1',
        '--set', 'controller.podLabels.app=ingress-nginx',
    ]
    
    # Only add nodeSelector if ingress-ready nodes exist (kind clusters)
    if _has_ingress_ready_node:
        _helm_flags.extend(['--set-string', 'controller.nodeSelector.ingress-ready=true'])
    
    # Install the ingress-nginx chart configured for kind
    # The controller will use the ingress-ready=true node label if available
    # Using --atomic=false and no --wait to prevent timeouts - pods will start in background
    helm_resource(
        'ingress-nginx',
        'ingress-nginx/ingress-nginx',
        namespace='ingress-nginx',
        resource_deps=['ingress-nginx-repo'],
        flags=_helm_flags + [
            # Don't wait for pods - let them start in background to avoid timeouts
            '--timeout', '2m',
        ],
    )
else:
    print("Existing ingress controller detected (e.g., traefik in k3d), skipping nginx-ingress deployment")

def name(c):
  return c['metadata']['name']

def namespace(c):
  if 'namespace' in c['metadata']:
    return c['metadata']['namespace']
  return ''

def decode(yaml):
  resources = decode_yaml_stream(yaml)

  # workaround a bug in decode_yaml_stream where it returns duplicates
  # This bug has been fixed in Tilt v0.17.3+
  filtered = []
  names = {}
  for r in resources:
    if r == None:
      continue

    n = '%s:%s:%s' % (name(r), r['kind'], namespace(r))
    if n in names:
      continue

    names[n] = True
    filtered.append(r)

  return filtered

def get_label(o, lbl):
  if 'labels' in o['metadata'] and lbl in o['metadata']['labels']:
    return o['metadata']['labels'][lbl]
  return ''

def find_overlapping(o, yamls):
  for elem in yamls:
    if name(o) == name(elem) and o['kind'] == elem['kind'] and namespace(o) == namespace(elem):
      return elem
  return None

# Parse all YAML files in our "generated" directory
yaml_objects = []
for filename in listdir('generated'):
  if filename.lower().endswith(('.yaml', '.yml')):
    decoded = decode(read_file(filename))
    yaml_objects += decoded
# Next, allow for additional yamls which can optionally override the generated yamls
for filename in listdir('additional'):
  if filename.lower().endswith(('.yaml', '.yml')):
    decoded = decode(read_file(filename))
    for o in decoded:
      present = find_overlapping(o, yaml_objects)
      if present != None:
        yaml_objects.remove(present)
    yaml_objects += decoded

bundle = encode_yaml_stream(yaml_objects)

# k8s_yaml automatically creates resources in Tilt for the entities
# and will inject any images referenced in the Tiltfile when deploying
# https://docs.tilt.dev/api.html#api.k8s_yaml
k8s_yaml(bundle)

# Group CRD's together
crds = [r for r in yaml_objects if (r['kind'] == 'CustomResourceDefinition')]
if len(crds) > 0:
  k8s_resource(new_name='CustomResourceDefinitions', objects=[('%s' % name(r)) for r in yaml_objects if (r['kind'] == 'CustomResourceDefinition')], resource_deps=['uncategorized'])

# Make webhooks dependent on all services starting
services = [('%s' % name(r)) for r in yaml_objects if r['kind'] == 'Service']
webhooks = [r for r in yaml_objects if (r['kind'] == 'ValidatingWebhookConfiguration' or r['kind'] == 'MutatingWebhookConfiguration')]
if len(webhooks) > 0:
  k8s_resource(new_name='Webhooks', objects=[('%s' % name(r)) for r in webhooks], resource_deps=services)
