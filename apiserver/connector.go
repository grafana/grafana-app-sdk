package apiserver

import (
	"context"
	"fmt"
	"net/http"
	"net/url"

	"github.com/grafana/grafana-app-sdk/resource"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/conversion"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apiserver/pkg/endpoints/request"
	"k8s.io/apiserver/pkg/registry/rest"
	"k8s.io/kube-openapi/pkg/common"
	"k8s.io/kube-openapi/pkg/validation/spec"
)

type ResourceCallOptions struct {
	metav1.TypeMeta

	// Path is the URL path to use for the current proxy request
	Path string
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ResourceCallOptions) DeepCopyInto(out *ResourceCallOptions) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	return
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ResourceCallOptions.
func (in *ResourceCallOptions) DeepCopy() *ResourceCallOptions {
	if in == nil {
		return nil
	}
	out := new(ResourceCallOptions)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *ResourceCallOptions) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

var _ = rest.Connecter(&SubresourceConnector{})

// TODO: customize rather than hard-code?
var methods = []string{"GET", "POST", "PUT", "PATCH", "DELETE", "HEAD", "OPTIONS"}

type SubresourceConnector struct {
	Routes []SubresourceRoute
}

func (r *SubresourceConnector) New() runtime.Object {
	return &ResourceCallOptions{}
}

func (r *SubresourceConnector) Destroy() {
}

func (r *SubresourceConnector) ConnectMethods() []string {
	return methods
}

func (r *SubresourceConnector) NewConnectOptions() (runtime.Object, bool, string) {
	return &ResourceCallOptions{}, true, "path"
}

func (r *SubresourceConnector) Connect(ctx context.Context, id string, opts runtime.Object, responder rest.Responder) (http.Handler, error) {
	resourceCallOpts, ok := opts.(*ResourceCallOptions)
	if !ok {
		return nil, fmt.Errorf("invalid options object: %#v", opts)
	}
	fmt.Println("ResourceCallREST.Connect() called with id:", id, "and opts:", resourceCallOpts)
	// TODO: map instead?
	info, ok := request.RequestInfoFrom(ctx)
	if !ok {
		return nil, fmt.Errorf("unable to retrieve request info from context")
	}
	identifier := resource.Identifier{
		Name:      info.Name,
		Namespace: info.Namespace,
	}
	for _, route := range r.Routes {
		if route.Path == info.Subresource {
			return &handlerWrapper{
				id:      identifier,
				handler: route.Handler,
			}, nil
		}
	}
	return nil, fmt.Errorf("no matching route for id '%s'", id)
}

type handlerWrapper struct {
	id      resource.Identifier
	handler AdditionalRouteHandler
}

func (h *handlerWrapper) ServeHTTP(w http.ResponseWriter, req *http.Request) {
	h.handler(w, req, h.id)
}

// CovertURLValuesToResourceCallOptions reads from the input *url.Values and assigns fields in the out *ResourceCallOptions
func CovertURLValuesToResourceCallOptions(in *url.Values, out *ResourceCallOptions, s conversion.Scope) error {
	if values, ok := map[string][]string(*in)["path"]; ok && len(values) > 0 {
		if err := runtime.Convert_Slice_string_To_string(&values, &out.Path, s); err != nil {
			return err
		}
	} else {
		out.Path = ""
	}
	return nil
}

func GetResourceCallOptionsOpenAPIDefinition() map[string]common.OpenAPIDefinition {
	return map[string]common.OpenAPIDefinition{
		"github.com/grafana/grafana-app-sdk/apiserver.ResourceCallOptions": common.OpenAPIDefinition{
			Schema: spec.Schema{
				SchemaProps: spec.SchemaProps{
					Description: "ExternalNameFoo defines model for ExternalNameFoo.",
					Type:        []string{"object"},
					Properties: map[string]spec.Schema{
						"kind": {
							SchemaProps: spec.SchemaProps{
								Type: []string{"string"},
							},
						},
						"apiVersion": {
							SchemaProps: spec.SchemaProps{
								Type: []string{"string"},
							},
						},
						"path": {
							SchemaProps: spec.SchemaProps{
								Default: "",
								Type:    []string{"string"},
								Format:  "",
							},
						},
					},
					Required: []string{"foo"},
				},
			},
		},
	}
}
