package jennies

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"path"
	"regexp"
	"strings"

	"github.com/grafana/codejen"

	"github.com/grafana/grafana-app-sdk/codegen"
	"github.com/grafana/grafana-app-sdk/codegen/templates"
)

type CustomRouteGoTypesJenny struct {
	// AddKubernetesCodegen toggles whether kubernetes codegen comments are added to the go types generated by this jenny.
	// The codegen comments can then be used with the OpenAPI jenny, or with the kubernetes codegen tooling.
	AddKubernetesCodegen bool

	// GroupByKind determines whether kinds are grouped by GroupVersionKind or just GroupVersion.
	// If GroupByKind is true, generated paths are <kind>/<version>/<file>, instead of the default <version>/<file>.
	// When GroupByKind is false, subresource types (such as spec and status) are prefixed with the kind name,
	// i.e. generating FooSpec instead of Spec for kind.Name() = "Foo" and Depth=1
	GroupByKind bool

	// AnyAsInterface determines whether to use `interface{}` instead of `any` in generated go code.
	// If true, `interface{}` will be used instead of `any`.
	AnyAsInterface bool
}

func (*CustomRouteGoTypesJenny) JennyName() string {
	return "CustomRouteTypes"
}

func (c *CustomRouteGoTypesJenny) Generate(appManifest codegen.AppManifest) (codejen.Files, error) {
	files := make(codejen.Files, 0)
	for _, version := range appManifest.Versions() {
		for _, kind := range version.Kinds() {
			for cpath, methods := range kind.Routes {
				for method, route := range methods {
					if route.Name == "" {
						route.Name = defaultRouteName(method, cpath)
					}
					generated, err := c.generateCustomRouteKinds(getGeneratedPathForKind(c.GroupByKind, appManifest.Properties().Group, kind, version.Name()), ToPackageName(version.Name()), kind.MachineName, route)
					if err != nil {
						return nil, fmt.Errorf("failed to generate custom route types for route %s, kind %s: %w", route.Name, kind.Kind, err)
					}
					files = append(files, generated...)
				}
			}
		}
	}
	return files, nil
}

func (c *CustomRouteGoTypesJenny) generateCustomRouteKinds(basePath string, packageName string, kindMachineName string, customRoute codegen.CustomRoute) (codejen.Files, error) {
	files := make(codejen.Files, 0)
	if !customRoute.Response.Schema.Exists() {
		return nil, fmt.Errorf("custom route response is required")
	}
	// Response
	typeName := exportField(customRoute.Name)
	// Get any modifications which will need to be done to the generated code (currently just kubernetes metadata)
	appendResponseBytes, appendResponseImports, bodyName := getCustomRouteAdditions(customRoute, typeName)
	responseTypes, err := GoTypesFromCUE(customRoute.Response.Schema, CUEGoConfig{
		PackageName:                    packageName,
		Name:                           toExportedFieldName(bodyName),
		NamePrefix:                     "", // TODO: not sure if we want this set
		AddKubernetesOpenAPIGenComment: c.AddKubernetesCodegen,
		AnyAsInterface:                 c.AnyAsInterface,
	}, 1)
	if err != nil {
		return nil, err
	}
	// Update the generated code based on the additions
	responseTypes, err = appendToGoBytes(responseTypes, appendResponseBytes, appendResponseImports...)
	if err != nil {
		return nil, fmt.Errorf("failed to add kubernetes metadata to response type: %w", err)
	}
	files = append(files, codejen.File{
		Data:         responseTypes,
		RelativePath: fmt.Sprintf(path.Join(basePath, "%s_%s_types_gen.go"), strings.ToLower(kindMachineName), strings.ToLower(customRoute.Name)),
		From:         []codejen.NamedJenny{c},
	})

	// Request
	requestTypeName := fmt.Sprintf("%sRequest", typeName)
	requestParamsTypeName := fmt.Sprintf("%sParams", requestTypeName)
	requestBodyTypeName := fmt.Sprintf("%sBody", requestTypeName)

	// Request Params
	if customRoute.Request.Query.Exists() {
		requestQueryType, err := GoTypesFromCUE(customRoute.Request.Query, CUEGoConfig{
			PackageName: packageName,
			Name:        requestParamsTypeName,
		}, 1)
		if err != nil {
			return nil, err
		}
		files = append(files, codejen.File{
			Data:         requestQueryType,
			RelativePath: fmt.Sprintf(path.Join(basePath, "%s_%s_request_params_types_gen.go"), strings.ToLower(kindMachineName), strings.ToLower(customRoute.Name)),
			From:         []codejen.NamedJenny{c},
		})

		requestQueryObjectType := bytes.Buffer{}
		err = templates.WriteRuntimeObjectWrapper(templates.RuntimeObjectWrapperMetadata{
			PackageName:     packageName,
			WrapperTypeName: fmt.Sprintf("%sObject", requestParamsTypeName),
			TypeName:        requestParamsTypeName,
		}, &requestQueryObjectType)
		if err != nil {
			return nil, err
		}
		files = append(files, codejen.File{
			Data:         requestQueryObjectType.Bytes(),
			RelativePath: fmt.Sprintf(path.Join(basePath, "%s_%s_request_params_object_gen.go"), strings.ToLower(kindMachineName), strings.ToLower(customRoute.Name)),
			From:         []codejen.NamedJenny{c},
		})
	}

	// Request Body
	if customRoute.Request.Body.Exists() {
		requestBodyType, err := GoTypesFromCUE(customRoute.Request.Body, CUEGoConfig{
			PackageName: packageName,
			Name:        requestBodyTypeName,
		}, 1)
		if err != nil {
			return nil, err
		}
		files = append(files, codejen.File{
			Data:         requestBodyType,
			RelativePath: fmt.Sprintf(path.Join(basePath, "%s_%s_request_body_types_gen.go"), strings.ToLower(kindMachineName), strings.ToLower(customRoute.Name)),
			From:         []codejen.NamedJenny{c},
		})
	}
	return files, nil
}

func defaultRouteName(method string, route string) string {
	ucFirstMethod := strings.ToUpper(method)
	if len(method) > 1 {
		ucFirstMethod = ucFirstMethod[:1] + strings.ToLower(method[1:])
	}
	for len(route) > 1 && route[0] == '/' {
		route = route[1:]
	}
	ucFirstPath := strings.ToUpper(route)
	if len(route) > 1 {
		ucFirstPath = ucFirstPath[:1] + route[1:]
	}
	return fmt.Sprintf("%s%s", ucFirstMethod, regexp.MustCompile("[^A-Za-z0-9_]").ReplaceAllString(ucFirstPath, ""))
}

func toExportedFieldName(name string) string {
	sanitized := regexp.MustCompile("[^A-Za-z0-9_]").ReplaceAllString(name, "")
	if len(sanitized) > 1 {
		return strings.ToUpper(sanitized[:1]) + sanitized[1:]
	}
	return strings.ToUpper(sanitized)
}

func getCustomRouteAdditions(customRoute codegen.CustomRoute, typeName string) (toAppend []byte, additionalImports []string, bodyName string) {
	bodyName = typeName
	additionalImports = make([]string, 0)
	if customRoute.Response.Metadata.ListMeta || customRoute.Response.Metadata.TypeMeta || customRoute.Response.Metadata.ObjectMeta {
		bodyName = typeName + "Body"
		additionalImports = append(additionalImports, `metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"`, `"k8s.io/apimachinery/pkg/runtime"`, `"github.com/grafana/grafana-app-sdk/resource"`)
		typeBytes := bytes.Buffer{}
		_, _ = typeBytes.WriteString(fmt.Sprintf("type %s struct {\n", typeName))
		if customRoute.Response.Metadata.TypeMeta {
			_, _ = typeBytes.WriteString("\tmetav1.TypeMeta `json:\",inline\"`\n")
		}
		if customRoute.Response.Metadata.ObjectMeta {
			_, _ = typeBytes.WriteString("\tmetav1.ObjectMeta `json:\"metadata\"`\n")
		}
		if customRoute.Response.Metadata.ListMeta {
			_, _ = typeBytes.WriteString("\tmetav1.ListMeta `json:\"metadata\"`\n")
		}
		_, _ = typeBytes.WriteString(fmt.Sprintf("\t%s `json:\",inline\"`\n}\n", bodyName))
		_, _ = typeBytes.WriteString(fmt.Sprintf("\nfunc New%s() *%s {\n\treturn &%s{}\n}\n", typeName, typeName, typeName))
		_, _ = typeBytes.Write(getCustomRouteResponseDeepCopyCode(customRoute, typeName, bodyName))
		toAppend = typeBytes.Bytes()
	}
	return toAppend, additionalImports, bodyName
}

func getCustomRouteResponseDeepCopyCode(customRoute codegen.CustomRoute, typeName string, bodyName string) []byte {
	if typeName == bodyName || !customRoute.Response.Metadata.TypeMeta {
		return []byte{}
	}
	buf := bytes.Buffer{}
	_, _ = buf.WriteString(fmt.Sprintf("\nfunc (b *%s) DeepCopyInto(dst *%s) {\n\tresource.CopyObjectInto(dst, b)\n}\n", bodyName, bodyName))
	_, _ = buf.WriteString(fmt.Sprintf("\nfunc (o *%s) DeepCopyObject() runtime.Object {\n\tdst := New%s()\n\to.DeepCopyInto(dst)\n\treturn dst\n}\n", typeName, typeName))
	_, _ = buf.WriteString(fmt.Sprintf("\nfunc (o *%s) DeepCopyInto(dst *%s) {\n", typeName, typeName))
	if customRoute.Response.Metadata.TypeMeta {
		_, _ = buf.WriteString(fmt.Sprintf("\tdst.TypeMeta.APIVersion = o.TypeMeta.APIVersion\n\tdst.TypeMeta.Kind = o.TypeMeta.Kind\n"))
	}
	if customRoute.Response.Metadata.ObjectMeta {
		_, _ = buf.WriteString(fmt.Sprintf("\to.ObjectMeta.DeepCopyInto(&dst.ObjectMeta)\n"))
	} else if customRoute.Response.Metadata.ListMeta {
		_, _ = buf.WriteString(fmt.Sprintf("\to.ListMeta.DeepCopyInto(&dst.ListMeta)\n"))
	}
	_, _ = buf.WriteString(fmt.Sprintf("\to.%s.DeepCopyInto(&dst.%s)\n}\n\nvar _ runtime.Object = &%s{}\n", bodyName, bodyName, typeName))
	return buf.Bytes()
}

func appendToGoBytes(existing []byte, toAppend []byte, additionalImports ...string) ([]byte, error) {
	if len(toAppend) == 0 && len(additionalImports) == 0 {
		return existing, nil
	}
	// combine existing and toAppend
	newContents := make([]byte, len(existing)+len(toAppend))
	copy(newContents, existing)
	copy(newContents[len(existing):], toAppend)

	// Parse the combined go code and add imports
	fset := token.NewFileSet() // A FileSet is needed for parsing
	node, err := parser.ParseFile(fset, "", newContents, parser.ParseComments)
	if err != nil {
		return nil, err
	}
	for _, imp := range additionalImports {
		newImport := &ast.ImportSpec{
			Path: &ast.BasicLit{
				Kind:  token.STRING,
				Value: imp,
			},
		}

		// Find or create an import declaration and add the new import
		foundImportDecl := false
		for _, decl := range node.Decls {
			genDecl, ok := decl.(*ast.GenDecl)
			if !ok || genDecl.Tok != token.IMPORT {
				continue
			}
			genDecl.Specs = append(genDecl.Specs, newImport)
			foundImportDecl = true
			break
		}

		if !foundImportDecl {
			// Create a new import declaration if none exists
			node.Decls = append([]ast.Decl{
				&ast.GenDecl{
					Tok:    token.IMPORT,
					Lparen: token.Pos(1), // Dummy position
					Specs:  []ast.Spec{newImport},
					//Rparen: token.Pos(1), // Dummy position
				},
			}, node.Decls...)
		}
	}

	var buf bytes.Buffer
	err = format.Node(&buf, fset, node)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
