package jennies

import (
	"bytes"
	"fmt"
	"path"
	"regexp"
	"strings"

	"github.com/grafana/codejen"

	"github.com/grafana/grafana-app-sdk/codegen"
	"github.com/grafana/grafana-app-sdk/codegen/templates"
)

type CustomRouteGoTypesJenny struct {
	// AddKubernetesCodegen toggles whether kubernetes codegen comments are added to the go types generated by this jenny.
	// The codegen comments can then be used with the OpenAPI jenny, or with the kubernetes codegen tooling.
	AddKubernetesCodegen bool

	// GroupByKind determines whether kinds are grouped by GroupVersionKind or just GroupVersion.
	// If GroupByKind is true, generated paths are <kind>/<version>/<file>, instead of the default <version>/<file>.
	// When GroupByKind is false, subresource types (such as spec and status) are prefixed with the kind name,
	// i.e. generating FooSpec instead of Spec for kind.Name() = "Foo" and Depth=1
	GroupByKind bool

	// AnyAsInterface determines whether to use `interface{}` instead of `any` in generated go code.
	// If true, `interface{}` will be used instead of `any`.
	AnyAsInterface bool
}

func (*CustomRouteGoTypesJenny) JennyName() string {
	return "CustomRouteTypes"
}

func (c *CustomRouteGoTypesJenny) Generate(appManifest codegen.AppManifest) (codejen.Files, error) {
	files := make(codejen.Files, 0)
	for _, version := range appManifest.Versions() {
		for _, kind := range version.Kinds() {
			for cpath, methods := range kind.CustomRoutes {
				for method, route := range methods {
					if route.Name == nil || *route.Name == "" {
						sanitized := defaultRouteName(method, cpath)
						route.Name = &sanitized
					}
					generated, err := c.generateCustomRouteKind(getGeneratedPathForKind(c.GroupByKind, appManifest.Properties().Group, kind, version.Name()), ToPackageName(version.Name()), kind.MachineName, route)
					if err != nil {
						return nil, fmt.Errorf("failed to generate custom route types for route %s, kind %s: %w", *route.Name, kind.Kind, err)
					}
					files = append(files, generated...)
				}
			}
		}
	}
	return files, nil
}

func (c *CustomRouteGoTypesJenny) generateCustomRouteKind(basePath string, packageName string, kindMachineName string, customRoute codegen.CustomRoute) (codejen.Files, error) {
	files := make(codejen.Files, 0)
	if !customRoute.Response.Schema.Exists() {
		return nil, fmt.Errorf("custom route response is required")
	}
	typeName := exportField(*customRoute.Name)
	responseTypes, err := GoTypesFromCUE(customRoute.Response.Schema, CUEGoConfig{
		PackageName:                    packageName,
		Name:                           typeName,
		NamePrefix:                     "", // TODO: not sure if we want this set
		AddKubernetesOpenAPIGenComment: c.AddKubernetesCodegen,
		AnyAsInterface:                 c.AnyAsInterface,
	}, 1)
	if err != nil {
		return nil, err
	}
	files = append(files, codejen.File{
		Data:         responseTypes,
		RelativePath: fmt.Sprintf(path.Join(basePath, "%s_%s_types_gen.go"), strings.ToLower(kindMachineName), strings.ToLower(*customRoute.Name)),
		From:         []codejen.NamedJenny{c},
	})
	// Methods to make it a runtime.Object
	runtimeObject := bytes.Buffer{}
	err = templates.WriteRuntimeObjectMethodsFile(templates.RuntimeObjectMethodsMetadata{
		Package:         packageName,
		TypeName:        typeName,
		ObjectShortName: strings.ToLower(typeName[0:1]),
	}, &runtimeObject)
	if err != nil {
		return nil, err
	}
	files = append(files, codejen.File{
		Data:         runtimeObject.Bytes(),
		RelativePath: fmt.Sprintf(path.Join(basePath, "%s_%s_wrapper_gen.go"), strings.ToLower(kindMachineName), strings.ToLower(*customRoute.Name)),
		From:         []codejen.NamedJenny{c},
	})
	return files, nil
}

func defaultRouteName(method string, path string) string {
	ucFirstMethod := strings.ToUpper(method)
	if len(method) > 1 {
		ucFirstMethod = ucFirstMethod[:1] + strings.ToLower(method[1:])
	}
	ucFirstPath := strings.ToUpper(path)
	if len(path) > 1 {
		ucFirstPath = ucFirstPath[:1] + path[1:]
	}
	return fmt.Sprintf("%s%s", ucFirstMethod, regexp.MustCompile("[^A-Za-z0-9_]").ReplaceAllString(ucFirstPath, ""))
}
