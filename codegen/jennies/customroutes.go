package jennies

import (
	"bytes"
	"errors"
	"fmt"
	"go/format"
	"net/http"
	"path"
	"path/filepath"
	"regexp"
	"strings"

	"github.com/grafana/codejen"
	"golang.org/x/tools/imports"

	"github.com/grafana/grafana-app-sdk/codegen"
	"github.com/grafana/grafana-app-sdk/codegen/templates"
)

type CustomRouteGoTypesJenny struct {
	// AddKubernetesCodegen toggles whether kubernetes codegen comments are added to the go types generated by this jenny.
	// The codegen comments can then be used with the OpenAPI jenny, or with the kubernetes codegen tooling.
	AddKubernetesCodegen bool

	// GroupByKind determines whether kinds are grouped by GroupVersionKind or just GroupVersion.
	// If GroupByKind is true, generated paths are <kind>/<version>/<file>, instead of the default <version>/<file>.
	// When GroupByKind is false, subresource types (such as spec and status) are prefixed with the kind name,
	// i.e. generating FooSpec instead of Spec for kind.Name() = "Foo" and Depth=1
	GroupByKind bool

	// AnyAsInterface determines whether to use `interface{}` instead of `any` in generated go code.
	// If true, `interface{}` will be used instead of `any`.
	AnyAsInterface bool
}

func (*CustomRouteGoTypesJenny) JennyName() string {
	return "CustomRouteTypes"
}

func (c *CustomRouteGoTypesJenny) Generate(appManifest codegen.AppManifest) (codejen.Files, error) {
	files := make(codejen.Files, 0)
	for _, version := range appManifest.Versions() {
		for _, kind := range version.Kinds() {
			for cpath, methods := range kind.Routes {
				for method, route := range methods {
					if route.Name == "" {
						route.Name = defaultRouteName(method, cpath)
					}
					generated, err := c.generateCustomRouteKinds(getGeneratedPathForKind(c.GroupByKind, appManifest.Properties().Group, kind, version.Name()), ToPackageName(version.Name()), strings.ToLower(kind.MachineName), route)
					if err != nil {
						return nil, fmt.Errorf("failed to generate custom route types for route %s, kind %s: %w", route.Name, kind.Kind, err)
					}
					files = append(files, generated...)
				}
			}
		}
		for cpath, methods := range version.Routes().Namespaced {
			for method, route := range methods {
				if route.Name == "" {
					route.Name = defaultRouteName(method, cpath)
				}
				generated, err := c.generateCustomRouteKinds(filepath.Join(ToPackageName(appManifest.Properties().Group), ToPackageName(version.Name())), ToPackageName(version.Name()), "", route)
				if err != nil {
					return nil, fmt.Errorf("failed to generate custom route types for route %s, version %s: %w", route.Name, version.Name(), err)
				}
				files = append(files, generated...)
			}
		}
		for cpath, methods := range version.Routes().Cluster {
			for method, route := range methods {
				if route.Name == "" {
					route.Name = defaultRouteName(method, cpath)
				}
				generated, err := c.generateCustomRouteKinds(filepath.Join(ToPackageName(appManifest.Properties().Group), ToPackageName(version.Name())), ToPackageName(version.Name()), "", route)
				if err != nil {
					return nil, fmt.Errorf("failed to generate custom route types for route %s, version %s: %w", route.Name, version.Name(), err)
				}
				files = append(files, generated...)
			}
		}
	}
	return files, nil
}

func (c *CustomRouteGoTypesJenny) generateCustomRouteKinds(basePath string, packageName string, filenamePrefix string, customRoute codegen.CustomRoute) (codejen.Files, error) {
	files := make(codejen.Files, 0)
	if !customRoute.Response.Schema.Exists() {
		return nil, errors.New("custom route response is required")
	}
	if !customRoute.Response.Metadata.TypeMeta && (customRoute.Response.Metadata.ListMeta || customRoute.Response.Metadata.ObjectMeta) {
		return nil, errors.New("custom route response metadata must have TypeMeta if ListMeta or ObjectMeta are present")
	}
	if filenamePrefix != "" {
		filenamePrefix = fmt.Sprintf("%s_", filenamePrefix)
	}
	// Response
	typeName := exportField(customRoute.Name)
	responseFiles, err := c.generateResponseTypes(customRoute, typeName, packageName, filenamePrefix, basePath)
	if err != nil {
		return nil, err
	}
	files = append(files, responseFiles...)

	// Request
	requestTypeName := fmt.Sprintf("%sRequest", typeName)
	requestParamsTypeName := fmt.Sprintf("%sParams", requestTypeName)

	// Request Params
	if customRoute.Request.Query.Exists() {
		requestQueryType, err := GoTypesFromCUE(customRoute.Request.Query, CUEGoConfig{
			PackageName: packageName,
			Name:        "Params",
			NamePrefix:  requestTypeName,
		}, 1)
		if err != nil {
			return nil, err
		}
		files = append(files, codejen.File{
			Data:         requestQueryType,
			RelativePath: fmt.Sprintf(path.Join(basePath, "%s%s_request_params_types_gen.go"), filenamePrefix, strings.ToLower(customRoute.Name)),
			From:         []codejen.NamedJenny{c},
		})

		requestQueryObjectType := bytes.Buffer{}
		err = templates.WriteRuntimeObjectWrapper(templates.RuntimeObjectWrapperMetadata{
			PackageName:     packageName,
			WrapperTypeName: fmt.Sprintf("%sObject", requestParamsTypeName),
			TypeName:        requestParamsTypeName,
		}, &requestQueryObjectType)
		if err != nil {
			return nil, err
		}
		files = append(files, codejen.File{
			Data:         requestQueryObjectType.Bytes(),
			RelativePath: fmt.Sprintf(path.Join(basePath, "%s%s_request_params_object_gen.go"), filenamePrefix, strings.ToLower(customRoute.Name)),
			From:         []codejen.NamedJenny{c},
		})
	}

	// Request Body
	if customRoute.Request.Body.Exists() {
		requestBodyType, err := GoTypesFromCUE(customRoute.Request.Body, CUEGoConfig{
			PackageName: packageName,
			Name:        "Body",
			NamePrefix:  requestTypeName,
		}, 1)
		if err != nil {
			return nil, err
		}
		files = append(files, codejen.File{
			Data:         requestBodyType,
			RelativePath: fmt.Sprintf(path.Join(basePath, "%s%s_request_body_types_gen.go"), filenamePrefix, strings.ToLower(customRoute.Name)),
			From:         []codejen.NamedJenny{c},
		})
	}
	return files, nil
}

func (c *CustomRouteGoTypesJenny) generateResponseTypes(customRoute codegen.CustomRoute, typeName, packageName, filenamePrefix, fileBasePath string) (codejen.Files, error) {
	if !customRoute.Response.Metadata.TypeMeta && (customRoute.Response.Metadata.ListMeta || customRoute.Response.Metadata.ObjectMeta) {
		return nil, errors.New("TypeMeta must be true if ObjectMeta or ListMeta is true")
	}
	files := make(codejen.Files, 0)
	bodyName := typeName
	if customRoute.Response.Metadata.ListMeta || customRoute.Response.Metadata.TypeMeta || customRoute.Response.Metadata.ObjectMeta {
		bodyName = typeName + "Body"
	}
	responseTypes, err := GoTypesFromCUE(customRoute.Response.Schema, CUEGoConfig{
		PackageName:                    packageName,
		Name:                           toExportedFieldName(bodyName),
		NamePrefix:                     "", // TODO: not sure if we want this set
		AddKubernetesOpenAPIGenComment: c.AddKubernetesCodegen,
		AnyAsInterface:                 c.AnyAsInterface,
	}, 1)
	if err != nil {
		return nil, err
	}
	body := ""
	if customRoute.Response.Metadata.TypeMeta {
		body = "body_"
	}
	formattedResponseTypes, err := formatGoBytes(responseTypes)
	if err != nil {
		return nil, fmt.Errorf("failed to format custom route types: %w", err)
	}
	files = append(files, codejen.File{
		Data:         formattedResponseTypes,
		RelativePath: fmt.Sprintf(path.Join(fileBasePath, "%s%s_response_%stypes_gen.go"), filenamePrefix, strings.ToLower(customRoute.Name), body),
		From:         []codejen.NamedJenny{c},
	})
	if customRoute.Response.Metadata.TypeMeta {
		buf := bytes.Buffer{}
		err = templates.WriteRuntimeObjectWrapper(templates.RuntimeObjectWrapperMetadata{
			PackageName:               packageName,
			TypeName:                  toExportedFieldName(bodyName),
			WrapperTypeName:           typeName,
			HasObjectMeta:             customRoute.Response.Metadata.ObjectMeta,
			HasListMeta:               customRoute.Response.Metadata.ListMeta,
			AddDeepCopyForTypeName:    true,
			KubernetesCodegenComments: true,
		}, &buf)
		if err != nil {
			return nil, fmt.Errorf("failed to write runtime.Object for custom route types: %w", err)
		}
		formatted, err := formatGoBytes(buf.Bytes())
		if err != nil {
			return nil, fmt.Errorf("failed to format custom route types: %w", err)
		}
		files = append(files, codejen.File{
			Data:         formatted,
			RelativePath: fmt.Sprintf(path.Join(fileBasePath, "%s%s_response_object_types_gen.go"), strings.ToLower(filenamePrefix), strings.ToLower(customRoute.Name)),
			From:         []codejen.NamedJenny{c},
		})
	}
	return files, nil
}

var httpMethodToK8sVerb = map[string]string{
	http.MethodGet:     "get",
	http.MethodPost:    "create",
	http.MethodPut:     "replace",
	http.MethodPatch:   "patch",
	http.MethodDelete:  "delete",
	http.MethodConnect: "connect",
	http.MethodOptions: "connect", // No real equivalent to options and head
	http.MethodHead:    "connect",
}

func defaultRouteName(method string, route string) string {
	for len(route) > 1 && route[0] == '/' {
		route = route[1:]
	}
	ucFirstPath := strings.ToUpper(route)
	if len(route) > 1 {
		ucFirstPath = ucFirstPath[:1] + route[1:]
	}
	return fmt.Sprintf("%s%s", httpMethodToK8sVerb[strings.ToUpper(method)], regexp.MustCompile("[^A-Za-z0-9_]").ReplaceAllString(ucFirstPath, ""))
}

func toExportedFieldName(name string) string {
	sanitized := regexp.MustCompile("[^A-Za-z0-9_]").ReplaceAllString(name, "")
	if len(sanitized) > 1 {
		return strings.ToUpper(sanitized[:1]) + sanitized[1:]
	}
	return strings.ToUpper(sanitized)
}

func formatGoBytes(b []byte) ([]byte, error) {
	formatted, err := format.Source(b)
	if err != nil {
		return nil, err
	}

	formatted, err = imports.Process("", formatted, &imports.Options{
		Comments: true,
	})
	if err != nil {
		return nil, err
	}
	return formatted, nil
}
