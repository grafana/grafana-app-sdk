//
// Code generated by grafana-app-sdk. DO NOT EDIT.
//

package customkind2

import (
	"embed"
	"encoding/json"
	"fmt"

	"cuelang.org/go/cue"
	"cuelang.org/go/cue/cuecontext"
	cjson "cuelang.org/go/encoding/json"
	"github.com/grafana/thema"
	"github.com/grafana/thema/load"
	"github.com/grafana/thema/vmux"
)

var rt = thema.NewRuntime(cuecontext.New())
var lineage thema.Lineage
var typedLatest thema.TypedSchema[*CustomKind2]

func init() {
	var err error
	if lineage, err = LoadLineage(rt); err != nil {
		panic(err)
	}
	if typedLatest, err = thema.BindType(lineage.Latest(), &CustomKind2{}); err != nil {
		panic(err)
	}
}

// Marshal uses the provided Encoder and version to marshal a CustomKind2, as the version provided.
// If no version is provided, it will use the latest (which reflects the structure of CustomKind2).
// If the provided version does not exist, it will return an error.
func Marshal(obj *CustomKind2, encoder vmux.Encoder, version string) ([]byte, error) {
	sVersion := lineage.Latest().Version()
	if version != "" {
		var err error
		sVersion, err = thema.ParseSyntacticVersion(version)
		if err != nil {
			return nil, err
		}
	}

	// TODO: this is messy, should be a better way
	j, err := json.Marshal(obj)
	if err != nil {
		return nil, err
	}
	expr, err := cjson.Extract("input", j)
	if err != nil {
		return nil, err
	}
	inst, err := lineage.Latest().Validate(rt.Context().BuildExpr(expr))
	if err != nil {
		return nil, err
	}
	translated, _ := inst.Translate(sVersion)
	if translated == nil {
		return nil, fmt.Errorf("cannot translate to version '%s'", sVersion)
	}
	return encoder.Encode(translated.Underlying())
}

// MarshalJSON is a convenience wrapper for Marshal that auto-provides the JSON Encoder
func MarshalJSON(obj *CustomKind2, version string) ([]byte, error) {
	return Marshal(obj, vmux.NewJSONCodec(""), version)
}

// MarshalYAML is a convenience wrapper for Marshal that auto-provides the YAML Encoder
func MarshalYAML(obj *CustomKind2, version string) ([]byte, error) {
	return Marshal(obj, vmux.NewYAMLCodec(""), version)
}

//go:embed customkind2_lineage.cue cue.mod/*
var modFS embed.FS

func loadLineage(lib *thema.Runtime) (cue.Value, error) {
	inst, err := load.InstanceWithThema(modFS, ".")
	if err != nil {
		return cue.Value{}, err
	}

	val := lib.Context().BuildInstance(inst)
	return val.LookupPath(cue.ParsePath("customkind2")), nil
}

// LoadLineage constructs a Go handle representing the CustomKind2 Object lineage,
// which includes the spec and all subresources.
func LoadLineage(rt *thema.Runtime, opts ...thema.BindOption) (thema.Lineage, error) {
	linval, err := loadLineage(rt)
	if err != nil {
		return nil, err
	}
	return thema.BindLineage(linval, rt, opts...)
}

var _ thema.LineageFactory = LoadLineage // Ensure our factory fulfills the type

// Lineage returns the cached loaded thema.Lineage for the CustomKind2 object
func Lineage() thema.Lineage {
	return lineage
}

// UnmarshalJSON is a convenience wrapper for Unmarshal which auto-provides the JSON Decoder
func UnmarshalJSON(b []byte, versionHint string) (*CustomKind2, error) {
	return Unmarshal(b, vmux.NewJSONCodec(""), versionHint)
}

// UnmarshalYAML is a convenience wrapper for Unmarshal which auto-provides the YAML Decoder
func UnmarshalYAML(b []byte, versionHint string) (*CustomKind2, error) {
	return Unmarshal(b, vmux.NewYAMLCodec(""), versionHint)
}

// Unmarshal unmarshals the provided bytes, using the Decoder and the versionHint.
// If no version is provided, it will walk the entire Lineage (from latest to earliest) and unmarshal the first
// schema match it finds. The unmarshaled bytes are always translated to the latest schema before being put into
// the returned *Wrapped struct.
func Unmarshal(b []byte, decoder vmux.Decoder, versionHint string) (*CustomKind2, error) {
	var typedInst *thema.TypedInstance[*CustomKind2]
	var lacunas thema.TranslationLacunas

	if versionHint != "" {
		version, err := thema.ParseSyntacticVersion(versionHint)
		if err != nil {
			return nil, fmt.Errorf("unable to parse version '%s': %w", versionHint, err)
		}
		sch, err := lineage.Schema(version)
		if err != nil {
			return nil, err
		}
		val, err := decoder.Decode(rt.Context(), b)
		if err != nil {
			return nil, err
		}
		inst, err := sch.Validate(val)
		if err != nil {
			return nil, err
		}
		var translated *thema.Instance
		translated, lacunas = inst.Translate(lineage.Latest().Version())
		typedInst, err = typedLatest.ValidateTyped(translated.Underlying())
		if err != nil {
			return nil, err
		}
	} else {
		var err error
		typedInst, lacunas, err = vmux.NewTypedMux[*CustomKind2](typedLatest, decoder)(b)
		if err != nil {
			return nil, err
		}
	}

	val, err := typedInst.Value()
	if err != nil {
		return nil, err
	}
	if lacunas != nil && len(lacunas.AsList()) > 0 {
		// TODO: handle lacunas? Should we return them?
	}
	return val, nil
}
