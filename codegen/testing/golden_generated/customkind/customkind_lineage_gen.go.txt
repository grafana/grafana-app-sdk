//
// Code generated by grafana-app-sdk. DO NOT EDIT.
//

package customkind

import (
	"embed"
	"encoding/json"

	"cuelang.org/go/cue"
	"cuelang.org/go/cue/cuecontext"
	"github.com/grafana/grafana-app-sdk/resource"
	"github.com/grafana/thema"
	"github.com/grafana/thema/load"
	"github.com/grafana/thema/vmux"
)

var rt = thema.NewRuntime(cuecontext.New())
var lineage thema.Lineage
var typedLatest thema.TypedSchema[*LineageType]
var muxer vmux.TypedMux[*LineageType]

// LacunaResolver is used by Object.Unmarshal to resolve any lacunas that emerge in the unmarshal process.
// It is skipped if nil, and should be overridden in non-generated code for custom lacuna resolution.
var LacunaResolver func(*LineageType, []thema.Lacuna) error = nil

// LineageType must be used instead of Object for thema.BindType, as the bound struct must exactly match the Schema,
// and Object has extra fields for metadata (which necessarily cannot be rendered in the Lineage/Schema,
// but must exist for the Object). This is essentially an "intermediate step" struct.
type LineageType struct {
	Spec     Spec     `json:"spec"`
	Status   Status   `json:"status"`
	Metadata Metadata `json:"metadata"`
}

func init() {
	var err error
	if lineage, err = Lineage(rt); err != nil {
		panic(err)
	}
	if typedLatest, err = thema.BindType(lineage.Latest(), &LineageType{}); err != nil {
		panic(err)
	}
	muxer = vmux.NewTypedMux[*LineageType](typedLatest, vmux.NewJSONCodec("input"))

	ObjectUnmarshalFunc = ThemaUnmarshalFunc
}

//go:embed customkind_lineage.cue cue.mod/*
var modFS embed.FS

func loadLineage(lib *thema.Runtime) (cue.Value, error) {
	inst, err := load.InstanceWithThema(modFS, ".")
	if err != nil {
		return cue.Value{}, err
	}

	val := lib.Context().BuildInstance(inst)
	return val.LookupPath(cue.ParsePath("customkind")), nil
}

// Lineage constructs a Go handle representing the Customkind Object lineage,
// which includes the spec and all subresources.
func Lineage(rt *thema.Runtime, opts ...thema.BindOption) (thema.Lineage, error) {
	linval, err := loadLineage(rt)
	if err != nil {
		return nil, err
	}
	return thema.BindLineage(linval, rt, opts...)
}

var _ thema.LineageFactory = Lineage // Ensure our factory fulfills the type

func ThemaUnmarshalFunc(into *Object, objBytes resource.ObjectBytes, config resource.UnmarshalConfig) error {
	// Unify the spec and subresources into one JSON object for the muxer
	unified := make(map[string]json.RawMessage)
	unified["spec"] = objBytes.Spec
	if sr, ok := objBytes.Subresources["spec"]; ok {
		unified["spec"] = sr
	}
	if sr, ok := objBytes.Subresources["status"]; ok {
		unified["status"] = sr
	}
	if sr, ok := objBytes.Subresources["metadata"]; ok {
		unified["metadata"] = sr
	}

	unified["metadata"] = objBytes.Metadata
	bytes, err := json.Marshal(unified)
	if err != nil {
		return err
	}

	// Parse with the muxer
	instance, lacunas, err := muxer(bytes)
	if err != nil {
		return err
	}
	parsedObj, err := instance.Value()
	if err != nil {
		return err
	}
	if lacunas != nil && len(lacunas.AsList()) > 0 && LacunaResolver != nil {
		err = LacunaResolver(parsedObj, lacunas.AsList())
		if err != nil {
			return err
		}
	}

	into.Spec = parsedObj.Spec
	into.Metadata = parsedObj.Metadata
	into.Spec = parsedObj.Spec
	into.Status = parsedObj.Status
	into.Metadata = parsedObj.Metadata
	return nil
}
