//
// Code generated by grafana-app-sdk. DO NOT EDIT.
//

package v1_0

import (
	"fmt"
	"github.com/grafana/grafana-app-sdk/resource"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"k8s.io/apimachinery/pkg/types"
	"time"
)

// +k8s:openapi-gen=true
type CustomKind struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata"`
	Spec              CustomKindSpec   `json:"spec"`
	Status            CustomKindStatus `json:"status"`
}

func (o *CustomKind) GetSpec() any {
	return o.Spec
}

func (o *CustomKind) SetSpec(spec any) error {
	cast, ok := spec.(CustomKindSpec)
	if !ok {
		return fmt.Errorf("cannot set spec type %#v, not of type Spec", spec)
	}
	o.Spec = cast
	return nil
}

func (o *CustomKind) GetSubresources() map[string]any {
	return map[string]any{
		"status": o.Status,
	}
}

func (o *CustomKind) GetSubresource(name string) (any, bool) {
	switch name {
	case "status":
		return o.Status, true
	default:
		return nil, false
	}
}

func (o *CustomKind) SetSubresource(name string, value any) error {
	switch name {
	case "status":
		cast, ok := value.(CustomKindStatus)
		if !ok {
			return fmt.Errorf("cannot set status type %#v, not of type CustomKindStatus", value)
		}
		o.Status = cast
		return nil
	default:
		return fmt.Errorf("subresource '%s' does not exist", name)
	}
}

func (o *CustomKind) GetStaticMetadata() resource.StaticMetadata {
	gvk := o.GroupVersionKind()
	return resource.StaticMetadata{
		Name:      o.ObjectMeta.Name,
		Namespace: o.ObjectMeta.Namespace,
		Group:     gvk.Group,
		Version:   gvk.Version,
		Kind:      gvk.Kind,
	}
}

func (o *CustomKind) SetStaticMetadata(metadata resource.StaticMetadata) {
	o.Name = metadata.Name
	o.Namespace = metadata.Namespace
	o.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   metadata.Group,
		Version: metadata.Version,
		Kind:    metadata.Kind,
	})
}

func (o *CustomKind) GetCommonMetadata() resource.CommonMetadata {
	dt := o.DeletionTimestamp
	var deletionTimestamp *time.Time
	if dt != nil {
		deletionTimestamp = &dt.Time
	}
	// Legacy ExtraFields support
	extraFields := make(map[string]any)
	if o.Annotations != nil {
		extraFields["annotations"] = o.Annotations
	}
	if o.ManagedFields != nil {
		extraFields["managedFields"] = o.ManagedFields
	}
	if o.OwnerReferences != nil {
		extraFields["ownerReferences"] = o.OwnerReferences
	}
	return resource.CommonMetadata{
		UID:               string(o.UID),
		ResourceVersion:   o.ResourceVersion,
		Generation:        o.Generation,
		Labels:            o.Labels,
		CreationTimestamp: o.CreationTimestamp.Time,
		DeletionTimestamp: deletionTimestamp,
		Finalizers:        o.Finalizers,
		UpdateTimestamp:   o.GetUpdateTimestamp(),
		CreatedBy:         o.GetCreatedBy(),
		UpdatedBy:         o.GetUpdatedBy(),
		ExtraFields:       extraFields,
	}
}

func (o *CustomKind) SetCommonMetadata(metadata resource.CommonMetadata) {
	o.UID = types.UID(metadata.UID)
	o.ResourceVersion = metadata.ResourceVersion
	o.Generation = metadata.Generation
	o.Labels = metadata.Labels
	o.CreationTimestamp = metav1.NewTime(metadata.CreationTimestamp)
	if metadata.DeletionTimestamp != nil {
		dt := metav1.NewTime(*metadata.DeletionTimestamp)
		o.DeletionTimestamp = &dt
	} else {
		o.DeletionTimestamp = nil
	}
	o.Finalizers = metadata.Finalizers
	if o.Annotations == nil {
		o.Annotations = make(map[string]string)
	}
	if !metadata.UpdateTimestamp.IsZero() {
		o.SetUpdateTimestamp(metadata.UpdateTimestamp)
	}
	if metadata.CreatedBy != "" {
		o.SetCreatedBy(metadata.CreatedBy)
	}
	if metadata.UpdatedBy != "" {
		o.SetUpdatedBy(metadata.UpdatedBy)
	}
	// Legacy support for setting Annotations, ManagedFields, and OwnerReferences via ExtraFields
	if metadata.ExtraFields != nil {
		if annotations, ok := metadata.ExtraFields["annotations"]; ok {
			if cast, ok := annotations.(map[string]string); ok {
				o.Annotations = cast
			}
		}
		if managedFields, ok := metadata.ExtraFields["managedFields"]; ok {
			if cast, ok := managedFields.([]metav1.ManagedFieldsEntry); ok {
				o.ManagedFields = cast
			}
		}
		if ownerReferences, ok := metadata.ExtraFields["ownerReferences"]; ok {
			if cast, ok := ownerReferences.([]metav1.OwnerReference); ok {
				o.OwnerReferences = cast
			}
		}
	}
}

func (o *CustomKind) GetCreatedBy() string {
	if o.ObjectMeta.Annotations == nil {
		o.ObjectMeta.Annotations = make(map[string]string)
	}

	return o.ObjectMeta.Annotations["grafana.com/createdBy"]
}

func (o *CustomKind) SetCreatedBy(createdBy string) {
	if o.ObjectMeta.Annotations == nil {
		o.ObjectMeta.Annotations = make(map[string]string)
	}

	o.ObjectMeta.Annotations["grafana.com/createdBy"] = createdBy
}

func (o *CustomKind) GetCustomMetadataField() string {
	if o.ObjectMeta.Annotations == nil {
		o.ObjectMeta.Annotations = make(map[string]string)
	}

	return o.ObjectMeta.Annotations["grafana.com/customMetadataField"]
}

func (o *CustomKind) SetCustomMetadataField(customMetadataField string) {
	if o.ObjectMeta.Annotations == nil {
		o.ObjectMeta.Annotations = make(map[string]string)
	}

	o.ObjectMeta.Annotations["grafana.com/customMetadataField"] = customMetadataField
}

func (o *CustomKind) GetOtherMetadataField() string {
	if o.ObjectMeta.Annotations == nil {
		o.ObjectMeta.Annotations = make(map[string]string)
	}

	return o.ObjectMeta.Annotations["grafana.com/otherMetadataField"]
}

func (o *CustomKind) SetOtherMetadataField(otherMetadataField string) {
	if o.ObjectMeta.Annotations == nil {
		o.ObjectMeta.Annotations = make(map[string]string)
	}

	o.ObjectMeta.Annotations["grafana.com/otherMetadataField"] = otherMetadataField
}

func (o *CustomKind) GetUpdateTimestamp() time.Time {
	if o.ObjectMeta.Annotations == nil {
		o.ObjectMeta.Annotations = make(map[string]string)
	}

	parsed, _ := time.Parse(time.RFC3339, o.ObjectMeta.Annotations["grafana.com/updateTimestamp"])
	return parsed
}

func (o *CustomKind) SetUpdateTimestamp(updateTimestamp time.Time) {
	if o.ObjectMeta.Annotations == nil {
		o.ObjectMeta.Annotations = make(map[string]string)
	}

	o.ObjectMeta.Annotations["grafana.com/updateTimestamp"] = updateTimestamp.Format(time.RFC3339)
}

func (o *CustomKind) GetUpdatedBy() string {
	if o.ObjectMeta.Annotations == nil {
		o.ObjectMeta.Annotations = make(map[string]string)
	}

	return o.ObjectMeta.Annotations["grafana.com/updatedBy"]
}

func (o *CustomKind) SetUpdatedBy(updatedBy string) {
	if o.ObjectMeta.Annotations == nil {
		o.ObjectMeta.Annotations = make(map[string]string)
	}

	o.ObjectMeta.Annotations["grafana.com/updatedBy"] = updatedBy
}

func (o *CustomKind) Copy() resource.Object {
	cpy := &CustomKind{}

	// Copy metadata
	o.ObjectMeta.DeepCopyInto(&cpy.ObjectMeta)

	// Copy Spec
	cpy.Spec.BoolField = o.Spec.BoolField
	cpy.Spec.Enum = o.Spec.Enum
	cpy.Spec.Field1 = o.Spec.Field1
	cpy.Spec.FloatField = o.Spec.FloatField
	cpy.Spec.I32 = o.Spec.I32
	cpy.Spec.I64 = o.Spec.I64
	cpy.Spec.Inner.InnerField1 = o.Spec.Inner.InnerField1
	if o.Spec.Inner.InnerField2 != nil {
		cpy.Spec.Inner.InnerField2 = make([]string, len(o.Spec.Inner.InnerField2))
		copy(cpy.Spec.Inner.InnerField2, o.Spec.Inner.InnerField2)
	}
	if o.Spec.Inner.InnerField3 != nil {
		cpy.Spec.Inner.InnerField3 = make([]CustomKindInnerObject2, len(o.Spec.Inner.InnerField3))
		copy(cpy.Spec.Inner.InnerField3, o.Spec.Inner.InnerField3)
	}
	cpy.Spec.Map = make(map[string]CustomKindType2)
	for key, val := range o.Spec.Map {
		cpyVal := CustomKindType2{}
		cpyVal.Details = make(map[string]any)
		for key, val := range val.Details {
			cpyVal.Details[key] = val
		}
		cpyVal.Group = val.Group

		cpy.Spec.Map[key] = cpyVal
	}
	cpy.Spec.Timestamp = o.Spec.Timestamp
	o.Spec.Union = cpy.Spec.Union

	// Copy Status
	cpy.Status.AdditionalFields = make(map[string]any)
	for key, val := range o.Status.AdditionalFields {
		cpy.Status.AdditionalFields[key] = val
	}
	cpy.Status.OperatorStates = make(map[string]CustomKindStatusOperatorState)
	for key, val := range o.Status.OperatorStates {
		cpyVal := CustomKindStatusOperatorState{}
		if val.DescriptiveState != nil {
			descriptiveStateCopy := *val.DescriptiveState
			cpyVal.DescriptiveState = &descriptiveStateCopy
		}
		cpyVal.Details = make(map[string]any)
		for key, val := range val.Details {
			cpyVal.Details[key] = val
		}
		cpyVal.LastEvaluation = val.LastEvaluation
		cpyVal.State = val.State

		cpy.Status.OperatorStates[key] = cpyVal
	}
	cpy.Status.StatusField1 = o.Status.StatusField1

	return cpy
}

func (o *CustomKind) DeepCopyObject() runtime.Object {
	return o.Copy()
}

// Interface compliance compile-time check
var _ resource.Object = &CustomKind{}

// +k8s:openapi-gen=true
type CustomKindList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata"`
	Items           []CustomKind `json:"items"`
}

func (o *CustomKindList) DeepCopyObject() runtime.Object {
	return o.Copy()
}

func (o *CustomKindList) Copy() resource.ListObject {
	cpy := &CustomKindList{
		TypeMeta: o.TypeMeta,
		Items:    make([]CustomKind, len(o.Items)),
	}
	o.ListMeta.DeepCopyInto(&cpy.ListMeta)
	for i := 0; i < len(o.Items); i++ {
		if item, ok := o.Items[i].Copy().(*CustomKind); ok {
			cpy.Items[i] = *item
		}
	}
	return cpy
}

func (o *CustomKindList) GetItems() []resource.Object {
	items := make([]resource.Object, len(o.Items))
	for i := 0; i < len(o.Items); i++ {
		items[i] = &o.Items[i]
	}
	return items
}

func (o *CustomKindList) SetItems(items []resource.Object) {
	o.Items = make([]CustomKind, len(items))
	for i := 0; i < len(items); i++ {
		o.Items[i] = *items[i].(*CustomKind)
	}
}

// Interface compliance compile-time check
var _ resource.ListObject = &CustomKindList{}
