// Code generated - EDITING IS FUTILE. DO NOT EDIT.

export interface InnerObject1 {
	innerField1: string;
	innerField2: string[];
	innerField3: InnerObject2[];
}

export const defaultInnerObject1 = (): InnerObject1 => ({
	innerField1: "",
	innerField2: [],
	innerField3: [],
});

export interface InnerObject2 {
	name: string;
	details: Record<string, any>;
}

export const defaultInnerObject2 = (): InnerObject2 => ({
	name: "",
	details: {},
});

export interface Type1 {
	group: string;
	options?: string[];
}

export const defaultType1 = (): Type1 => ({
	group: "",
});

export interface Type2 {
	group: string;
	details: Record<string, any>;
}

export const defaultType2 = (): Type2 => ({
	group: "",
	details: {},
});

export type UnionType = Type1 | Type2;

export const defaultUnionType = (): UnionType => (defaultType1());

export interface OperatorState {
	// lastEvaluation is the ResourceVersion last evaluated
	lastEvaluation: string;
	// state describes the state of the lastEvaluation.
	// It is limited to three possible states for machine evaluation.
	state: "success" | "in_progress" | "failed";
	// descriptiveState is an optional more descriptive state field which has no requirements on format
	descriptiveState?: string;
	// details contains any extra information that is operator-specific
	details?: Record<string, any>;
}

export const defaultOperatorState = (): OperatorState => ({
	lastEvaluation: "",
	state: "success",
});

export interface CustomKind {
	spec: {
		field1: string;
		inner: InnerObject1;
		union: UnionType;
		map: Record<string, Type2>;
		timestamp: string;
		enum: "val1" | "val2" | "val3" | "val4" | "default";
		i32: number;
		i64: number;
		boolField: boolean;
		floatField: number;
	};
	status: {
		statusField1: string;
		// operatorStates is a map of operator ID to operator state evaluations.
		// Any operator which consumes this kind SHOULD add its state evaluation information to this field.
		operatorStates?: Record<string, OperatorState>;
		// additionalFields is reserved for future use
		additionalFields?: Record<string, any>;
	};
	// metadata contains embedded CommonMetadata and can be extended with custom string fields
	// TODO: use CommonMetadata instead of redefining here; currently needs to be defined here
	// without external reference as using the CommonMetadata reference breaks thema codegen.
	metadata: {
		// All extensions to this metadata need to have string values (for APIServer encoding-to-annotations purposes)
		// Can't use this as it's not yet enforced CUE:
		// ...string
		// Have to do this gnarly regex instead
		customMetadataField: string;
		updateTimestamp: string;
		createdBy: string;
		uid: string;
		creationTimestamp: string;
		deletionTimestamp?: string;
		finalizers: string[];
		resourceVersion: string;
		generation: number;
		// All extensions to this metadata need to have string values (for APIServer encoding-to-annotations purposes)
		// Can't use this as it's not yet enforced CUE:
		// ...string
		// Have to do this gnarly regex instead
		otherMetadataField: string;
		updatedBy: string;
		labels: Record<string, string>;
	};
}

export const defaultCustomKind = (): CustomKind => ({
	spec: {
	field1: "",
	inner: defaultInnerObject1(),
	union: defaultUnionType(),
	map: {},
	timestamp: "",
	enum: "default",
	i32: 0,
	i64: 0,
	boolField: false,
	floatField: 0,
},
	status: {
	statusField1: "",
},
	metadata: {
	customMetadataField: "",
	updateTimestamp: "",
	createdBy: "",
	uid: "",
	creationTimestamp: "",
	finalizers: [],
	resourceVersion: "",
	generation: 0,
	otherMetadataField: "",
	updatedBy: "",
	labels: {},
},
});

