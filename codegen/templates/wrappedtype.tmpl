//
// Code generated by grafana-app-sdk. DO NOT EDIT.
//

package {{.Package}}

import (
	"embed"
	"encoding/json"
	"fmt"

	"cuelang.org/go/cue"
	"cuelang.org/go/cue/cuecontext"
	cjson "cuelang.org/go/encoding/json"
	"github.com/grafana/thema"
	"github.com/grafana/thema/load"
	"github.com/grafana/thema/vmux"
)

var rt = thema.NewRuntime(cuecontext.New())
var lineage thema.Lineage
var typedLatest thema.TypedSchema[*{{.TypeName}}]

func init() {
	var err error
	if lineage, err = LoadLineage(rt); err != nil {
		panic(err)
	}
	if typedLatest, err = thema.BindType(lineage.Latest(), &{{.TypeName}}{}); err != nil {
		panic(err)
	}
}

// Marshal uses the provided Encoder and version to marshal a {{.TypeName}}, as the version provided.
// If no version is provided, it will use the latest (which reflects the structure of {{.TypeName}}).
// If the provided version does not exist, it will return an error.
func Marshal(obj *{{.TypeName}}, encoder vmux.Encoder, version string) ([]byte, error) {
    sVersion := lineage.Latest().Version()
    if version != "" {
        var err error
        sVersion, err = thema.ParseSyntacticVersion(version)
        if err != nil {
            return nil, err
        }
    }

    // TODO: this is messy, should be a better way
    j, err := json.Marshal(obj)
    if err != nil {
        return nil, err
    }
    expr, err := cjson.Extract("input", j)
    if err != nil {
        return nil, err
    }
    inst, err := lineage.Latest().Validate(rt.Context().BuildExpr(expr))
    if err != nil {
        return nil, err
    }
    translated, _ := inst.Translate(sVersion)
    if translated == nil {
        return nil, fmt.Errorf("cannot translate to version '%s'", sVersion)
    }
    return encoder.Encode(translated.Underlying())
}

// MarshalJSON is a convenience wrapper for Marshal that auto-provides the JSON Encoder
func MarshalJSON(obj *{{.TypeName}}, version string) ([]byte, error) {
	return Marshal(obj, vmux.NewJSONCodec(""), version)
}

// MarshalYAML is a convenience wrapper for Marshal that auto-provides the YAML Encoder
func MarshalYAML(obj *{{.TypeName}}, version string) ([]byte, error) {
	return Marshal(obj, vmux.NewYAMLCodec(""), version)
}

//go:embed {{.CUEFile}} cue.mod/*
var modFS embed.FS

func loadLineage(lib *thema.Runtime) (cue.Value, error) {
	inst, err := load.InstanceWithThema(modFS, ".")
	if err != nil {
		return cue.Value{}, err
	}

	val := lib.Context().BuildInstance(inst)
	return val.LookupPath(cue.ParsePath("{{.CUESelector}}")), nil
}

// LoadLineage constructs a Go handle representing the {{.TypeName}} Object lineage,
// which includes the spec and all subresources.
func LoadLineage(rt *thema.Runtime, opts ...thema.BindOption) (thema.Lineage, error) {
	linval, err := loadLineage(rt)
	if err != nil {
		return nil, err
	}
	return thema.BindLineage(linval, rt, opts...)
}

var _ thema.LineageFactory = LoadLineage // Ensure our factory fulfills the type

// Lineage returns the cached loaded thema.Lineage for the {{.TypeName}} object
func Lineage() thema.Lineage {
    return lineage
}

// UnmarshalJSON is a convenience wrapper for Unmarshal which auto-provides the JSON Decoder
func UnmarshalJSON(b []byte, versionHint string) (*{{.TypeName}}, error) {
	return Unmarshal(b, vmux.NewJSONCodec(""), versionHint)
}

// UnmarshalYAML is a convenience wrapper for Unmarshal which auto-provides the YAML Decoder
func UnmarshalYAML(b []byte, versionHint string) (*{{.TypeName}}, error) {
	return Unmarshal(b, vmux.NewYAMLCodec(""), versionHint)
}

// Unmarshal unmarshals the provided bytes, using the Decoder and the versionHint.
// If no version is provided, it will walk the entire Lineage (from latest to earliest) and unmarshal the first
// schema match it finds. The unmarshaled bytes are always translated to the latest schema before being put into
// the returned *Wrapped struct.
func Unmarshal(b []byte, decoder vmux.Decoder, versionHint string) (*{{.TypeName}}, error) {
	var typedInst *thema.TypedInstance[*{{.TypeName}}]
	var lacunas thema.TranslationLacunas

	if versionHint != "" {
		version, err := thema.ParseSyntacticVersion(versionHint)
		if err != nil {
			return nil, fmt.Errorf("unable to parse version '%s': %w", versionHint, err)
		}
		sch, err := lineage.Schema(version)
		if err != nil {
			return nil, err
		}
		val, err := decoder.Decode(rt.Context(), b)
		if err != nil {
			return nil, err
		}
		inst, err := sch.Validate(val)
		if err != nil {
			return nil, err
		}
		var translated *thema.Instance
		translated, lacunas = inst.Translate(lineage.Latest().Version())
		typedInst, err = typedLatest.ValidateTyped(translated.Underlying())
		if err != nil {
			return nil, err
		}
	} else {
		var err error
		typedInst, lacunas, err = vmux.NewTypedMux[*{{.TypeName}}](typedLatest, decoder)(b)
		if err != nil {
			return nil, err
		}
	}

	val, err := typedInst.Value()
	if err != nil {
		return nil, err
	}
	if lacunas != nil && len(lacunas.AsList()) > 0 {
		// TODO: handle lacunas? Should we return them?
	}
	return val, nil
}
