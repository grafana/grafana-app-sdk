//
// Code generated by grafana-app-sdk. DO NOT EDIT.
//

package {{.Package}}
{{$sfl := len .SelectableFields}}
{{$needsFmt := false}}{{range .SelectableFields}}{{if ne .Type "string"}}{{$needsFmt = true}}{{end}}{{end}}
import (
    {{if gt $sfl 0}}
    "errors"{{if $needsFmt}}
    "fmt"{{end}}
    {{end}}

    "github.com/grafana/grafana-app-sdk/resource"
)
{{$root:=.}}
// schema is unexported to prevent accidental overwrites
var (
    schema{{.Kind}} = resource.NewSimpleSchema("{{.Group}}", "{{.Version}}", New{{.Kind}}(), &{{.Kind}}List{}, resource.WithKind("{{.Kind}}"),
        resource.WithPlural("{{.Plural}}"), resource.WithScope(resource.{{.Scope}}Scope) {{if gt $sfl 0}}, resource.WithSelectableFields([]resource.SelectableField{ {{ range .SelectableFields }}resource.SelectableField{
            FieldSelector: "{{.Field}}",
            FieldValueFunc: func(o resource.Object) (string, error) {
                cast, ok := o.(*{{$root.Kind}})
                if !ok {
                    return "", errors.New("provided object must be of type *{{$root.Kind}}")
                }{{ range .OptionalFieldsInPath }}
                if cast.{{$root.ToObjectPath .}} == nil {
                    return "", nil
                }{{ end }}
                {{ if .Optional }}{{ if eq .Type "string" }}
                return *cast.{{$root.ToObjectPath .Field}}, nil{{ else if eq .Type "int" }}
                return fmt.Sprintf("%d", *cast.{{$root.ToObjectPath .Field}}), nil{{ else }}
                return fmt.Sprintf("%v", *cast.{{$root.ToObjectPath .Field}}), nil{{ end }}{{ else }}{{ if eq .Type "string" }}
                return cast.{{$root.ToObjectPath .Field}}, nil{{ else if eq .Type "int" }}
                return fmt.Sprintf("%d", cast.{{$root.ToObjectPath .Field}}), nil{{ else }}
                return fmt.Sprintf("%v", cast.{{$root.ToObjectPath .Field}}), nil{{ end }}{{ end }}
            },
        },
        {{ end }} }){{ end }})
    kind{{.Kind}} = resource.Kind{
        Schema: schema{{.Kind}},
        Codecs: map[resource.KindEncoding]resource.Codec{
            resource.KindEncodingJSON: &{{.FuncPrefix}}JSONCodec{},
        },
    }
)

// Kind returns a resource.Kind for this Schema with a JSON codec
func {{.FuncPrefix}}Kind() resource.Kind {
    return kind{{.Kind}}
}

// Schema returns a resource.SimpleSchema representation of {{.Kind}}
func {{.FuncPrefix}}Schema() *resource.SimpleSchema {
    return schema{{.Kind}}
}

// Interface compliance checks
var _ resource.Schema = kind{{.Kind}}
