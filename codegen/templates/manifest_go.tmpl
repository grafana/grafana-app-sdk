//
// This file is generated by grafana-app-sdk
// DO NOT EDIT
//

package {{.Package}}

import (
    "encoding/json"
    "strings"

    "github.com/grafana/grafana-app-sdk/app"
    "github.com/grafana/grafana-app-sdk/resource"
    "k8s.io/kube-openapi/pkg/spec3"
    "k8s.io/kube-openapi/pkg/validation/spec"

    {{ range .Packages }}{{ . }}
    {{ end }}
)

{{ define "schema" }}
SchemaProps: spec.SchemaProps{
    {{ if .Type }}Type: []string{ {{ range $index, $type := .Type }}{{ if $index }}, {{ end }}"{{$type}}"{{ end }} },{{ end }}{{ if .Format }}
    Format: "{{.Format}}",{{ end }}{{ if .Description }}
    Description: "{{.Description}}",{{ end }}{{ if .Enum }}
    Enum: []interface{}{ {{ range .Enum }}
        "{{.}}",{{ end }}
    },{{ end }}{{ if .Properties }}
    Properties: map[string]spec.Schema{ {{ range $key, $prop := .Properties }}
        "{{$key}}": { {{ template "schema" $prop }}
        },{{ end }}
    },{{ end }}{{ if .AdditionalProperties }}
    AdditionalProperties: &spec.SchemaOrBool{ {{ if .AdditionalProperties.Schema }}
        Schema: &spec.Schema{ {{ template "schema" .AdditionalProperties.Schema }}
        },{{ else }}
        Allows: {{ .AdditionalProperties.Allows }},{{ end }}
    },{{ end }}{{ if .Required }}
    Required: []string{ {{ range .Required }}
        "{{.}}",{{ end }}
    },{{ end }}{{ if (refString .Ref) }}
    Ref: spec.MustCreateRef("{{ .Ref | refString }}"),{{ end }}
},{{ if .Extensions }}
VendorExtensible: spec.VendorExtensible{
    Extensions: spec.Extensions{ {{ range $key, $val := .Extensions }}
        "{{ $key }}": {{printf "%#v" $val}},{{ end }}
    },
},{{ end }}{{ end }}

{{ define "parameter" }}
{ {{ if .Name }}
    ParameterProps: spec3.ParameterProps{
        Name: "{{.Name}}",{{ end }}{{ if .In }}
        In: "{{.In}}",{{ end }}{{ if .Description }}
        Description: "{{.Description}}",{{ end }}{{ if .Required }}
        Required: {{.Required}},{{ end }}{{ if .Schema }}
        Schema: &spec.Schema{ {{ template "schema" .Schema }}
        },
    },{{ end }}
},{{ end }}

{{ define "mediaTypeContent" }}
MediaTypeProps: spec3.MediaTypeProps{
    {{ if .Schema }}Schema: &spec.Schema{ {{ template "schema" .Schema }} },{{ end }}
    {{ if .Example }}Example: {{ printf "%#v" .Example }},{{ end }}
    {{ if .Examples }}Examples: map[string]*spec3.Example{
        {{ range $key, $example := .Examples }}"{{$key}}": {
            ExampleProps: spec3.ExampleProps{
                {{ if $example.Summary }}Summary: "{{$example.Summary}}",{{ end }}
                {{ if $example.Description }}Description: "{{$example.Description}}",{{ end }}
                {{ if $example.Value }}Value: map[string]interface{}{
                    {{- range $k, $v := $example.Value }}
                    "{{$k}}": {{- if eq (printf "%T" $v) "string" -}}"{{$v}}"{{- else -}}{{printf "%#v" $v}}{{- end -}},
                    {{- end }}
                },{{ end }}
                {{ if $example.ExternalValue }}ExternalValue: "{{$example.ExternalValue}}",{{ end }}
            },
        },{{ end }}
    },{{ end }}
},{{ end }}

{{ define "responses" }}
ResponsesProps: spec3.ResponsesProps{
    {{ if .Default }}Default: {{ template "response" .Default }},{{ end }}
    {{ if .StatusCodeResponses }}StatusCodeResponses: map[int]*spec3.Response{ {{ range $code, $response := .StatusCodeResponses }}
        {{$code}}: {{ template "response" $response }},{{ end }}
    },{{ end }}
},{{ end }}

{{ define "response" }}
&spec3.Response{
    ResponseProps: spec3.ResponseProps{
        {{ if .Description }}Description: "{{.Description}}",{{ end }}
        {{ if .Content }}Content: map[string]*spec3.MediaType{ {{ range $contentType, $mediaType := .Content }}
            "{{$contentType}}": { {{ template "mediaTypeContent" $mediaType }} },{{ end }}
        },{{ end }}
    },
}{{ end }}

{{ define "requestBody" }}
RequestBodyProps: spec3.RequestBodyProps{
    {{ if .Description }}Description: "{{.Description}}",{{ end }}
    {{ if .Required }}Required: {{.Required}},{{ end }}
    {{ if .Content }}Content: map[string]*spec3.MediaType{ {{ range $contentType, $mediaType := .Content }}
        "{{$contentType}}": { {{ template "mediaTypeContent" $mediaType }} },{{ end }}
    },{{ end }}
},{{ end }}

{{ define "operation" }}
OperationProps: spec3.OperationProps{
    {{ if .Summary }}Summary: "{{.Summary}}",{{ end }}
    {{ if .Description }}Description: "{{.Description}}",{{ end }}
    {{ if .OperationId }}OperationId: "{{.OperationId}}",{{ end }}
    {{ if .Tags }}Tags: []string{ {{ range $index, $tag := .Tags }}{{ if $index }}, {{ end }}"{{$tag}}"{{ end }} },{{ end }}
    {{ if .ExternalDocs }}ExternalDocs: &spec3.ExternalDocumentation{
        {{ if .ExternalDocs.URL }}URL: "{{.ExternalDocs.URL}}",{{ end }}
        {{ if .ExternalDocs.Description }}Description: "{{.ExternalDocs.Description}}",{{ end }}
    },{{ end }}
    {{ if .Parameters }}Parameters: []*spec3.Parameter{ {{ range .Parameters }}
        {{ template "parameter" . }}{{ end }}
    },{{ end }}
    {{ if .RequestBody }}RequestBody: &spec3.RequestBody{ {{ template "requestBody" .RequestBody }} },{{ end }}
    {{ if .Responses }}Responses: &spec3.Responses{ {{ template "responses" .Responses }} },{{ end }}
    {{ if .Deprecated }}Deprecated: {{.Deprecated}},{{ end }}
    {{ if .SecurityRequirement }}SecurityRequirement: []map[string][]string{ {{ range .SecurityRequirement }}
        { {{ range $key, $scopes := . }}
            "{{$key}}": []string{ {{ range $index, $scope := $scopes }}{{ if $index }}, {{ end }}"{{$scope}}"{{ end }} },{{ end }}
        },{{ end }}
    },{{ end }}
    {{ if .Servers }}Servers: []*spec3.Server{ {{ range .Servers }}
        {
            {{ if .URL }}URL: "{{.URL}}",{{ end }}
            {{ if .Description }}Description: "{{.Description}}",{{ end }}
        },{{ end }}
    },{{ end }}
},{{ end }}

var ({{ range .ManifestData.Versions }}{{$v:=.}}{{ range .Kinds }}{{ if .Schema }}
    rawSchema{{.Kind}}{{$.ToPackageName $v.Name}} = []byte({{$.ToJSONBacktickString .Schema}})
    versionSchema{{.Kind}}{{$.ToPackageName $v.Name}} app.VersionSchema
    _ = json.Unmarshal(rawSchema{{.Kind}}{{$.ToPackageName $v.Name}}, &versionSchema{{.Kind}}{{$.ToPackageName $v.Name}}){{end}}{{end}}{{end}}
)

var appManifestData = app.ManifestData{
    AppName: "{{.ManifestData.AppName}}",
    Group: "{{.ManifestData.Group}}",
    Versions: []app.ManifestVersion{ {{ range .ManifestData.Versions }}{{$v:=.}}
        {
            Name: "{{.Name}}",
            Served: {{.Served}},
            Kinds: []app.ManifestVersionKind{ {{ range .Kinds }}
            {
                Kind: "{{.Kind}}",
                Plural: "{{.Plural}}",
                Scope: "{{.Scope}}",
                Conversion: {{.Conversion}}, {{ if .Admission }}
                Admission: &app.AdmissionCapabilities{
                    {{ if .Admission.Validation }} Validation: &app.ValidationCapability{
                        {{ if .Admission.Validation.Operations }} Operations: []app.AdmissionOperation{
                        {{ range .Admission.Validation.Operations }}app.{{ $.ToAdmissionOperationName . }},
                        {{ end }} }, {{ end }}
                    }, {{ end }}
                    {{ if .Admission.Mutation }} Mutation: &app.MutationCapability{
                        {{ if .Admission.Mutation.Operations }} Operations: []app.AdmissionOperation{
                        {{ range .Admission.Mutation.Operations }}app.{{ $.ToAdmissionOperationName . }},
                        {{ end }} }, {{ end }}
                    }, {{ end }}
                }, {{ end }}{{ if .Schema }}
                Schema: &versionSchema{{.Kind}}{{$.ToPackageName $v.Name}},{{end}}{{ if .SelectableFields }}
                SelectableFields: []string{ {{ range .SelectableFields }}
                    "{{.}}",{{ end }}
                },{{end}}{{ if .Routes }}
                Routes: map[string]spec3.PathProps{ {{ range $path, $props := .Routes }}{{ if $props }}
                    "{{$path}}": { {{ if $props.Summary }}
                        Summary: "{{$props.Summary}}",{{ end }}{{ if $props.Description }}
                        Description: "{{$props.Description}}",{{ end }}{{ if $props.Parameters }}
                        Parameters: []spec3.Parameter{ {{ range $props.Parameters }}
                            {{ template "parameter" . }}{{ end }}
                        },{{ end }}{{ if $props.Get }}
                        Get: &spec3.Operation{ {{ template "operation" $props.Get }}
                        },{{ end }}{{ if $props.Post }}
                        Post: &spec3.Operation{ {{ template "operation" $props.Post }}
                        },{{ end }}{{ if $props.Put }}
                        Put: &spec3.Operation{ {{ template "operation" $props.Put }}
                        },{{ end }}{{ if $props.Delete }}
                        Delete: &spec3.Operation{ {{ template "operation" $props.Delete }}
                        },{{ end }}{{ if $props.Patch }}
                        Patch: &spec3.Operation{ {{ template "operation" $props.Patch }}
                        },{{ end }}
                    },{{ end }}{{ end }}
                },{{end}}
            },
            {{ end }} },
            Routes: app.ManifestVersionRoutes{
                Namespaced: map[string]spec3.PathProps{ {{ range $path, $props := .Routes.Namespaced }}{{ if $props }}
                    "{{$path}}": { {{ if $props.Summary }}
                        Summary: "{{$props.Summary}}",{{ end }}{{ if $props.Description }}
                        Description: "{{$props.Description}}",{{ end }}{{ if $props.Parameters }}
                        Parameters: []spec3.Parameter{ {{ range $props.Parameters }}
                            {{ template "parameter" . }}{{ end }}
                        },{{ end }}{{ if $props.Get }}
                        Get: &spec3.Operation{ {{ template "operation" $props.Get }}
                        },{{ end }}{{ if $props.Post }}
                        Post: &spec3.Operation{ {{ template "operation" $props.Post }}
                        },{{ end }}{{ if $props.Put }}
                        Put: &spec3.Operation{ {{ template "operation" $props.Put }}
                        },{{ end }}{{ if $props.Delete }}
                        Delete: &spec3.Operation{ {{ template "operation" $props.Delete }}
                        },{{ end }}{{ if $props.Patch }}
                        Patch: &spec3.Operation{ {{ template "operation" $props.Patch }}
                        },{{ end }}
                    },{{ end }}{{ end }}
                },
                Cluster: map[string]spec3.PathProps{ {{ range $path, $props := .Routes.Cluster }}{{ if $props }}
                    "{{$path}}": { {{ if $props.Summary }}
                        Summary: "{{$props.Summary}}",{{ end }}{{ if $props.Description }}
                        Description: "{{$props.Description}}",{{ end }}{{ if $props.Parameters }}
                        Parameters: []spec3.Parameter{ {{ range $props.Parameters }}
                            {{ template "parameter" . }}{{ end }}
                        },{{ end }}{{ if $props.Get }}
                        Get: &spec3.Operation{ {{ template "operation" $props.Get }}
                        },{{ end }}{{ if $props.Post }}
                        Post: &spec3.Operation{ {{ template "operation" $props.Post }}
                        },{{ end }}{{ if $props.Put }}
                        Put: &spec3.Operation{ {{ template "operation" $props.Put }}
                        },{{ end }}{{ if $props.Delete }}
                        Delete: &spec3.Operation{ {{ template "operation" $props.Delete }}
                        },{{ end }}{{ if $props.Patch }}
                        Patch: &spec3.Operation{ {{ template "operation" $props.Patch }}
                        },{{ end }}
                    },{{ end }}{{ end }}
                },
                Schemas: map[string]spec.Schema{ {{ range $refName, $schema := .Routes.Schemas }}
                    "{{ $refName }}": { {{ template "schema" $schema }}
                    },{{ end }}
                },
            },
        },
        {{ end }} },{{ if .ManifestData.ExtraPermissions }}
        ExtraPermissions: &app.Permissions{
            AccessKinds: []app.KindPermission{ {{ range .ManifestData.ExtraPermissions.AccessKinds }} 
                {
                    Group: "{{ .Group }}",
                    Resource: "{{ .Resource }}",
                    Actions: []app.KindPermissionAction{ {{ range .Actions }} 
                        "{{ . }}",{{ end }}
                    },
                },{{ end }} 
            },
        },{{ end }}{{ if .ManifestData.Operator }}
    Operator: &app.ManifestOperatorInfo{
        URL: "{{.ManifestData.Operator.URL}}", {{ if .ManifestData.Operator.Webhooks }}
        Webhooks: &app.ManifestOperatorWebhookProperties{
            ConversionPath: "{{.ManifestData.Operator.Webhooks.ConversionPath}}",
            ValidationPath: "{{.ManifestData.Operator.Webhooks.ValidationPath}}",
            MutationPath: "{{.ManifestData.Operator.Webhooks.MutationPath}}",
        },{{ end }}
    },{{ end }}
}

func LocalManifest() app.Manifest {
    return app.NewEmbeddedManifest(appManifestData)
}

func RemoteManifest() app.Manifest {
    return app.NewAPIServerManifest("{{ .ManifestData.AppName }}")
}

var kindVersionToGoType = map[string]resource.Kind { {{ range .ManifestData.Versions }}{{$v:=.}}{{ range .Kinds }}
    "{{ .Kind }}/{{ $v.Name }}": {{ if $.KindsAreGrouped }}{{ $.ToPackageName $v.Name}}.{{ $.GoKindName .Kind }}Kind(){{ else }}{{ $.KindToPackageName .Kind }}{{ $.ToPackageName $v.Name }}.Kind(){{ end }},{{ end }}{{ end }}
}

// ManifestGoTypeAssociator returns the associated resource.Kind instance for a given Kind and Version, if one exists.
// If there is no association for the provided Kind and Version, exists will return false.
func ManifestGoTypeAssociator(kind, version string) (goType resource.Kind, exists bool) {
    goType, exists = kindVersionToGoType[fmt.Sprintf("%s/%s", kind, version)]
    return goType, exists
}

var customRouteToGoResponseType = map[string]any { {{ range .ManifestData.Versions }}{{$v:=.}}{{ range .Kinds }}{{$k := .}}{{ range $path, $resp := .Routes }}{{ if $resp.Get }}
    "{{ $v.Name }}|{{ $k.Kind }}|{{ $.StripLeadingSlash $path }}|GET": {{ if $.KindsAreGrouped }}{{ $.ToPackageName $v.Name}}.{{ $.ExportedFieldName $resp.Get.OperationId }}{{ else }}{{ $.KindToPackageName $k.Kind }}{{ $.ToPackageName $v.Name }}.{{ $.ExportedFieldName $resp.Get.OperationId }}{{ end }}{},{{end}}{{ if $resp.Post }}
    "{{ $v.Name }}|{{ $k.Kind }}|{{ $.StripLeadingSlash $path }}|POST": {{ if $.KindsAreGrouped }}{{ $.ToPackageName $v.Name}}.{{ $.ExportedFieldName $resp.Post.OperationId }}{{ else }}{{ $.KindToPackageName $k.Kind }}{{ $.ToPackageName $v.Name }}.{{ $.ExportedFieldName $resp.Post.OperationId }}{{ end }}{},{{end}}{{ if $resp.Put }}
    "{{ $v.Name }}|{{ $k.Kind }}|{{ $.StripLeadingSlash $path }}|PUT": {{ if $.KindsAreGrouped }}{{ $.ToPackageName $v.Name}}.{{ $.ExportedFieldName $resp.Put.OperationId }}{{ else }}{{ $.KindToPackageName $k.Kind }}{{ $.ToPackageName $v.Name }}.{{ $.ExportedFieldName $resp.Put.OperationId }}{{ end }}{},{{end}}{{ if $resp.Patch }}
    "{{ $v.Name }}|{{ $k.Kind }}|{{ $.StripLeadingSlash $path }}|PATCH": {{ if $.KindsAreGrouped }}{{ $.ToPackageName $v.Name}}.{{ $.ExportedFieldName $resp.Patch.OperationId }}{{ else }}{{ $.KindToPackageName $k.Kind }}{{ $.ToPackageName $v.Name }}.{{ $.ExportedFieldName $resp.Patch.OperationId }}{{ end }}{},{{end}}{{ if $resp.Delete }}
    "{{ $v.Name }}|{{ $k.Kind }}|{{ $.StripLeadingSlash $path }}|DELETE": {{ if $.KindsAreGrouped }}{{ $.ToPackageName $v.Name}}.{{ $.ExportedFieldName $resp.Delete.OperationId }}{{ else }}{{ $.KindToPackageName $k.Kind }}{{ $.ToPackageName $v.Name }}.{{ $.ExportedFieldName $resp.Delete.OperationId }}{{ end }}{},{{end}}{{ if $resp.Head }}
    "{{ $v.Name }}|{{ $k.Kind }}|{{ $.StripLeadingSlash $path }}|HEAD": {{ if $.KindsAreGrouped }}{{ $.ToPackageName $v.Name}}.{{ $.ExportedFieldName $resp.Head.OperationId }}{{ else }}{{ $.KindToPackageName $k.Kind }}{{ $.ToPackageName $v.Name }}.{{ $.ExportedFieldName $resp.Head.OperationId }}{{ end }}{},{{end}}{{ if $resp.Options }}
    "{{ $v.Name }}|{{ $k.Kind }}|{{ $.StripLeadingSlash $path }}|OPTIONS": {{ if $.KindsAreGrouped }}{{ $.ToPackageName $v.Name}}.{{ $.ExportedFieldName $resp.Options.OperationId }}{{ else }}{{ $.KindToPackageName $k.Kind }}{{ $.ToPackageName $v.Name }}.{{ $.ExportedFieldName $resp.Options.OperationId }}{{ end }}{},{{end}}
    {{ end }}{{ end }}{{ range $path, $resp := .Routes.Namespaced }}{{ if $resp.Get }}
    "{{ $v.Name}}||<namespace>/{{ $.StripLeadingSlash $path }}|GET": {{ $.ToPackageName $v.Name}}.{{ $.ExportedFieldName $resp.Get.OperationId }}{},{{ end }}{{ if $resp.Post }}
    "{{ $v.Name}}||<namespace>/{{ $.StripLeadingSlash $path }}|POST": {{ $.ToPackageName $v.Name}}.{{ $.ExportedFieldName $resp.Post.OperationId }}{},{{ end }}{{ if $resp.Put }}
    "{{ $v.Name}}||<namespace>/{{ $.StripLeadingSlash $path }}|PUT": {{ $.ToPackageName $v.Name}}.{{ $.ExportedFieldName $resp.Put.OperationId }}{},{{ end }}{{ if $resp.Patch }}
    "{{ $v.Name}}||<namespace>/{{ $.StripLeadingSlash $path }}|PATCH": {{ $.ToPackageName $v.Name}}.{{ $.ExportedFieldName $resp.Patch.OperationId }}{},{{ end }}{{ if $resp.Delete }}
    "{{ $v.Name}}||<namespace>/{{ $.StripLeadingSlash $path }}|DELETE": {{ $.ToPackageName $v.Name}}.{{ $.ExportedFieldName $resp.Delete.OperationId }}{},{{ end }}{{ if $resp.Head }}
    "{{ $v.Name}}||<namespace>/{{ $.StripLeadingSlash $path }}|HEAD": {{ $.ToPackageName $v.Name}}.{{ $.ExportedFieldName $resp.Head.OperationId }}{},{{ end }}{{ if $resp.Options }}
    "{{ $v.Name}}||<namespace>/{{ $.StripLeadingSlash $path }}|OPTIONS": {{ $.ToPackageName $v.Name}}.{{ $.ExportedFieldName $resp.Options.OperationId }}{},{{ end }}{{ end }}{{ range $path, $resp := .Routes.Cluster }}{{ if $resp.Get }}
    "{{ $v.Name}}||{{ $.StripLeadingSlash $path }}|GET": {{ $.ToPackageName $v.Name}}.{{ $.ExportedFieldName $resp.Get.OperationId }}{},{{ end }}{{ if $resp.Post }}
    "{{ $v.Name}}||{{ $.StripLeadingSlash $path }}|POST": {{ $.ToPackageName $v.Name}}.{{ $.ExportedFieldName $resp.Post.OperationId }}{},{{ end }}{{ if $resp.Put }}
    "{{ $v.Name}}||{{ $.StripLeadingSlash $path }}|PUT": {{ $.ToPackageName $v.Name}}.{{ $.ExportedFieldName $resp.Put.OperationId }}{},{{ end }}{{ if $resp.Patch }}
    "{{ $v.Name}}||{{ $.StripLeadingSlash $path }}|PATCH": {{ $.ToPackageName $v.Name}}.{{ $.ExportedFieldName $resp.Patch.OperationId }}{},{{ end }}{{ if $resp.Delete }}
    "{{ $v.Name}}||{{ $.StripLeadingSlash $path }}|DELETE": {{ $.ToPackageName $v.Name}}.{{ $.ExportedFieldName $resp.Delete.OperationId }}{},{{ end }}{{ if $resp.Head }}
    "{{ $v.Name}}||{{ $.StripLeadingSlash $path }}|HEAD": {{ $.ToPackageName $v.Name}}.{{ $.ExportedFieldName $resp.Head.OperationId }}{},{{ end }}{{ if $resp.Options }}
    "{{ $v.Name}}||{{ $.StripLeadingSlash $path }}|OPTIONS": {{ $.ToPackageName $v.Name}}.{{ $.ExportedFieldName $resp.Options.OperationId }}{},{{ end }}{{ end }}
    {{ end }}
}

// ManifestCustomRouteResponsesAssociator returns the associated response go type for a given kind, version, custom route path, and method, if one exists.
// kind may be empty for custom routes which are not kind subroutes. Leading slashes are removed from subroute paths.
// If there is no association for the provided kind, version, custom route path, and method, exists will return false.
// Resource routes (those without a kind) should prefix their route with "<namespace>/" if the route is namespaced (otherwise the route is assumed to be cluster-scope)
func ManifestCustomRouteResponsesAssociator(kind, version, path, verb string) (goType any, exists bool) {
    if len(path) > 0 && path[0] == '/' {
        path = path[1:]
    }
    goType, exists = customRouteToGoResponseType[fmt.Sprintf("%s|%s|%s|%s", version, kind, path, strings.ToUpper(verb))]
    return goType, exists
}

var customRouteToGoParamsType = map[string]runtime.Object { {{ range .ManifestData.Versions }}{{$v:=.}}{{ range .Kinds }}{{$k := .}}{{ range $path, $resp := .Routes }}{{ if and $resp.Get $resp.Get.Parameters }}
    "{{ $v.Name }}|{{ $k.Kind }}|{{ $.StripLeadingSlash $path }}|GET": &{{ if $.KindsAreGrouped }}{{ $.ToPackageName $v.Name}}.{{ $.ExportedFieldName $resp.Get.OperationId }}RequestParamsObject{{ else }}{{ $.KindToPackageName $k.Kind }}{{ $.ToPackageName $v.Name }}.{{ $.ExportedFieldName $resp.Get.OperationId }}RequestParamsObject{{ end }}{},{{end}}{{ if and $resp.Post $resp.Post.Parameters }}
    "{{ $v.Name }}|{{ $k.Kind }}|{{ $.StripLeadingSlash $path }}|POST": {{ if $.KindsAreGrouped }}{{ $.ToPackageName $v.Name}}.{{ $.ExportedFieldName $resp.Post.OperationId }}RequestParamsObject{{ else }}{{ $.KindToPackageName $k.Kind }}{{ $.ToPackageName $v.Name }}.{{ $.ExportedFieldName $resp.Post.OperationId }}RequestParamsObject{{ end }}{},{{end}}{{ if and $resp.Put $resp.Put.Parameters }}
    "{{ $v.Name }}|{{ $k.Kind }}|{{ $.StripLeadingSlash $path }}|PUT": {{ if $.KindsAreGrouped }}{{ $.ToPackageName $v.Name}}.{{ $.ExportedFieldName $resp.Put.OperationId }}RequestParamsObject{{ else }}{{ $.KindToPackageName $k.Kind }}{{ $.ToPackageName $v.Name }}.{{ $.ExportedFieldName $resp.Put.OperationId }}RequestParamsObject{{ end }}{},{{end}}{{ if and $resp.Patch $resp.Patch.Parameters }}
    "{{ $v.Name }}|{{ $k.Kind }}|{{ $.StripLeadingSlash $path }}|PATCH": {{ if $.KindsAreGrouped }}{{ $.ToPackageName $v.Name}}.{{ $.ExportedFieldName $resp.Patch.OperationId }}RequestParamsObject{{ else }}{{ $.KindToPackageName $k.Kind }}{{ $.ToPackageName $v.Name }}.{{ $.ExportedFieldName $resp.Patch.OperationId }}RequestParamsObject{{ end }}{},{{end}}{{ if and $resp.Delete $resp.Delete.Parameters }}
    "{{ $v.Name }}|{{ $k.Kind }}|{{ $.StripLeadingSlash $path }}|DELETE": {{ if $.KindsAreGrouped }}{{ $.ToPackageName $v.Name}}.{{ $.ExportedFieldName $resp.Delete.OperationId }}RequestParamsObject{{ else }}{{ $.KindToPackageName $k.Kind }}{{ $.ToPackageName $v.Name }}.{{ $.ExportedFieldName $resp.Delete.OperationId }}RequestParamsObject{{ end }}{},{{end}}{{ if and $resp.Head $resp.Head.Parameters }}
    "{{ $v.Name }}|{{ $k.Kind }}|{{ $.StripLeadingSlash $path }}|HEAD": {{ if $.KindsAreGrouped }}{{ $.ToPackageName $v.Name}}.{{ $.ExportedFieldName $resp.Head.OperationId }}RequestParamsObject{{ else }}{{ $.KindToPackageName $k.Kind }}{{ $.ToPackageName $v.Name }}.{{ $.ExportedFieldName $resp.Head.OperationId }}RequestParamsObject{{ end }}{},{{end}}{{ if and $resp.Options $resp.Options.Parameters }}
    "{{ $v.Name }}|{{ $k.Kind }}|{{ $.StripLeadingSlash $path }}|OPTIONS": {{ if $.KindsAreGrouped }}{{ $.ToPackageName $v.Name}}.{{ $.ExportedFieldName $resp.Options.OperationId }}RequestParamsObject{{ else }}{{ $.KindToPackageName $k.Kind }}{{ $.ToPackageName $v.Name }}.{{ $.ExportedFieldName $resp.Options.OperationId }}RequestParamsObject{{ end }}{},{{end}}
    {{ end }}{{ end }}{{ end }}
}

func ManifestCustomRouteQueryAssociator(kind, version, path, verb string) (goType runtime.Object, exists bool) {
    if len(path) > 0 && path[0] == '/' {
        path = path[1:]
    }
    goType, exists = customRouteToGoParamsType[fmt.Sprintf("%s|%s|%s|%s", version, kind, path, strings.ToUpper(verb))]
    return goType, exists
}

var customRouteToGoRequestBodyType = map[string]any { {{ range .ManifestData.Versions }}{{$v:=.}}{{ range .Kinds }}{{$k := .}}{{ range $path, $resp := .Routes }}{{ if and $resp.Get $resp.Get.RequestBody }}
    "{{ $v.Name }}|{{ $k.Kind }}|{{ $.StripLeadingSlash $path }}|GET": &{{ if $.KindsAreGrouped }}{{ $.ToPackageName $v.Name}}.{{ $.ExportedFieldName $resp.Get.OperationId }}RequestBody{{ else }}{{ $.KindToPackageName $k.Kind }}{{ $.ToPackageName $v.Name }}.{{ $.ExportedFieldName $resp.Get.OperationId }}RequestBody{{ end }}{},{{end}}{{ if and $resp.Post $resp.Post.RequestBody }}
    "{{ $v.Name }}|{{ $k.Kind }}|{{ $.StripLeadingSlash $path }}|POST": {{ if $.KindsAreGrouped }}{{ $.ToPackageName $v.Name}}.{{ $.ExportedFieldName $resp.Post.OperationId }}RequestBody{{ else }}{{ $.KindToPackageName $k.Kind }}{{ $.ToPackageName $v.Name }}.{{ $.ExportedFieldName $resp.Post.OperationId }}RequestBody{{ end }}{},{{end}}{{ if and $resp.Put $resp.Put.RequestBody }}
    "{{ $v.Name }}|{{ $k.Kind }}|{{ $.StripLeadingSlash $path }}|PUT": {{ if $.KindsAreGrouped }}{{ $.ToPackageName $v.Name}}.{{ $.ExportedFieldName $resp.Put.OperationId }}RequestBody{{ else }}{{ $.KindToPackageName $k.Kind }}{{ $.ToPackageName $v.Name }}.{{ $.ExportedFieldName $resp.Put.OperationId }}RequestBody{{ end }}{},{{end}}{{ if and $resp.Patch $resp.Patch.RequestBody }}
    "{{ $v.Name }}|{{ $k.Kind }}|{{ $.StripLeadingSlash $path }}|PATCH": {{ if $.KindsAreGrouped }}{{ $.ToPackageName $v.Name}}.{{ $.ExportedFieldName $resp.Patch.OperationId }}RequestBody{{ else }}{{ $.KindToPackageName $k.Kind }}{{ $.ToPackageName $v.Name }}.{{ $.ExportedFieldName $resp.Patch.OperationId }}RequestBody{{ end }}{},{{end}}{{ if and $resp.Delete $resp.Delete.RequestBody }}
    "{{ $v.Name }}|{{ $k.Kind }}|{{ $.StripLeadingSlash $path }}|DELETE": {{ if $.KindsAreGrouped }}{{ $.ToPackageName $v.Name}}.{{ $.ExportedFieldName $resp.Delete.OperationId }}RequestBody{{ else }}{{ $.KindToPackageName $k.Kind }}{{ $.ToPackageName $v.Name }}.{{ $.ExportedFieldName $resp.Delete.OperationId }}RequestBody{{ end }}{},{{end}}{{ if and $resp.Head $resp.Head.RequestBody }}
    "{{ $v.Name }}|{{ $k.Kind }}|{{ $.StripLeadingSlash $path }}|HEAD": {{ if $.KindsAreGrouped }}{{ $.ToPackageName $v.Name}}.{{ $.ExportedFieldName $resp.Head.OperationId }}RequestBody{{ else }}{{ $.KindToPackageName $k.Kind }}{{ $.ToPackageName $v.Name }}.{{ $.ExportedFieldName $resp.Head.OperationId }}RequestBody{{ end }}{},{{end}}{{ if and $resp.Options $resp.Options.RequestBody }}
    "{{ $v.Name }}|{{ $k.Kind }}|{{ $.StripLeadingSlash $path }}|OPTIONS": {{ if $.KindsAreGrouped }}{{ $.ToPackageName $v.Name}}.{{ $.ExportedFieldName $resp.Options.OperationId }}RequestBody{{ else }}{{ $.KindToPackageName $k.Kind }}{{ $.ToPackageName $v.Name }}.{{ $.ExportedFieldName $resp.Options.OperationId }}RequestBody{{ end }}{},{{end}}
    {{ end }}{{ end }}{{ range $path, $resp := .Routes.Namespaced }}{{ if and $resp.Get $resp.Get.RequestBody }}
    "{{ $v.Name}}||<namespace>/{{ $.StripLeadingSlash $path }}|GET": {{ $.ToPackageName $v.Name}}.{{ $.ExportedFieldName $resp.Get.OperationId }}RequestBody{},{{ end }}{{ if and $resp.Post $resp.Post.RequestBody }}
    "{{ $v.Name}}||<namespace>/{{ $.StripLeadingSlash $path }}|POST": {{ $.ToPackageName $v.Name}}.{{ $.ExportedFieldName $resp.Post.OperationId }}RequestBody{},{{ end }}{{ if and $resp.Put $resp.Put.RequestBody }}
    "{{ $v.Name}}||<namespace>/{{ $.StripLeadingSlash $path }}|PUT": {{ $.ToPackageName $v.Name}}.{{ $.ExportedFieldName $resp.Put.OperationId }}RequestBody{},{{ end }}{{ if and $resp.Patch $resp.Patch.RequestBody }}
    "{{ $v.Name}}||<namespace>/{{ $.StripLeadingSlash $path }}|PATCH": {{ $.ToPackageName $v.Name}}.{{ $.ExportedFieldName $resp.Patch.OperationId }}RequestBody{},{{ end }}{{ if and $resp.Delete $resp.Delete.RequestBody }}
    "{{ $v.Name}}||<namespace>/{{ $.StripLeadingSlash $path }}|DELETE": {{ $.ToPackageName $v.Name}}.{{ $.ExportedFieldName $resp.Delete.OperationId }}RequestBody{},{{ end }}{{ if and $resp.Head $resp.Head.RequestBody }}
    "{{ $v.Name}}||<namespace>/{{ $.StripLeadingSlash $path }}|HEAD": {{ $.ToPackageName $v.Name}}.{{ $.ExportedFieldName $resp.Head.OperationId }}RequestBody{},{{ end }}{{ if and $resp.Options $resp.Options.RequestBody }}
    "{{ $v.Name}}||<namespace>/{{ $.StripLeadingSlash $path }}|OPTIONS": {{ $.ToPackageName $v.Name}}.{{ $.ExportedFieldName $resp.Options.OperationId }}RequestBody{},{{ end }}{{ end }}{{ range $path, $resp := .Routes.Cluster }}{{ if and $resp.Get $resp.Get.RequestBody }}
    "{{ $v.Name}}||{{ $.StripLeadingSlash $path }}|GET": {{ $.ToPackageName $v.Name}}.{{ $.ExportedFieldName $resp.Get.OperationId }}RequestBody{},{{ end }}{{ if and $resp.Post $resp.Post.RequestBody }}
    "{{ $v.Name}}||{{ $.StripLeadingSlash $path }}|POST": {{ $.ToPackageName $v.Name}}.{{ $.ExportedFieldName $resp.Post.OperationId }}RequestBody{},{{ end }}{{ if and $resp.Put $resp.Put.RequestBody }}
    "{{ $v.Name}}||{{ $.StripLeadingSlash $path }}|PUT": {{ $.ToPackageName $v.Name}}.{{ $.ExportedFieldName $resp.Put.OperationId }}RequestBody{},{{ end }}{{ if and $resp.Patch $resp.Patch.RequestBody }}
    "{{ $v.Name}}||{{ $.StripLeadingSlash $path }}|PATCH": {{ $.ToPackageName $v.Name}}.{{ $.ExportedFieldName $resp.Patch.OperationId }}RequestBody{},{{ end }}{{ if and $resp.Delete $resp.Delete.RequestBody }}
    "{{ $v.Name}}||{{ $.StripLeadingSlash $path }}|DELETE": {{ $.ToPackageName $v.Name}}.{{ $.ExportedFieldName $resp.Delete.OperationId }}RequestBody{},{{ end }}{{ if and $resp.Head $resp.Head.RequestBody }}
    "{{ $v.Name}}||{{ $.StripLeadingSlash $path }}|HEAD": {{ $.ToPackageName $v.Name}}.{{ $.ExportedFieldName $resp.Head.OperationId }}RequestBody{},{{ end }}{{ if and $resp.Options $resp.Options.RequestBody }}
    "{{ $v.Name}}||{{ $.StripLeadingSlash $path }}|OPTIONS": {{ $.ToPackageName $v.Name}}.{{ $.ExportedFieldName $resp.Options.OperationId }}RequestBody{},{{ end }}{{ end }}
    {{ end }}
}

func ManifestCustomRouteRequestBodyAssociator(kind, version, path, verb string) (goType any, exists bool) {
    if len(path) > 0 && path[0] == '/' {
        path = path[1:]
    }
    goType, exists = customRouteToGoRequestBodyType[fmt.Sprintf("%s|%s|%s|%s", version, kind, path, strings.ToUpper(verb))]
    return goType, exists
}

type GoTypeAssociator struct {}

func NewGoTypeAssociator() *GoTypeAssociator {
    return &GoTypeAssociator{}
}

func (g *GoTypeAssociator) KindToGoType(kind, version string) (goType resource.Kind, exists bool) {
    return ManifestGoTypeAssociator(kind, version)
}
func (g *GoTypeAssociator) CustomRouteReturnGoType(kind, version, path, verb string) (goType any, exists bool) {
    return ManifestCustomRouteResponsesAssociator(kind, version, path, verb)
}
func (g *GoTypeAssociator) CustomRouteQueryGoType(kind, version, path, verb string) (goType runtime.Object, exists bool) {
    return ManifestCustomRouteQueryAssociator(kind, version, path, verb)
}
func (g *GoTypeAssociator) CustomRouteRequestBodyGoType(kind, version, path, verb string) (goType any, exists bool) {
    return ManifestCustomRouteRequestBodyAssociator(kind, version, path, verb)
}
