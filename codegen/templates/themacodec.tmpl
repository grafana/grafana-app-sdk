//
// Code generated by grafana-app-sdk. DO NOT EDIT.
//

package {{.Package}}

import ({{ range .CustomMetadataFields }}{{ range $imp := .GoType.AdditionalImports }}
    "{{$imp}}"{{ end }}{{ end }}
    "fmt"
    "encoding/json"
    "io"

    "github.com/grafana/grafana-app-sdk/resource"
)

// JSONCodec is an implementation of resource.Codec for kubernetes JSON encoding using thema
type JSONCodec struct {}

// Read reads JSON-encoded bytes from `reader` and unmarshals them into `into`
func (*JSONCodec) Read(reader io.Reader, into resource.Object) error {
    cast, ok := into.(*{{.ObjectTypeName}})
    if !ok {
        return fmt.Errorf("can only read into type *{{.Package}}.{{.ObjectTypeName}}")
    }

    temp := &resource.TypedSpecStatusObject[json.RawMessage,json.RawMessage]{}
    err := json.NewDecoder(reader).Decode(temp)
    if err != nil {
        return err
    }
    // Re-encode metadata
    annotations := temp.GetAnnotations()
    if annotations == nil {
        annotations = make(map[string]string)
    }
    md := Metadata{
        Finalizers: temp.GetFinalizers(),
        Generation: temp.GetGeneration(),
        Labels: temp.GetLabels(),
        ResourceVersion: temp.GetResourceVersion(),
        Uid: string(temp.GetUID()),
        CreationTimestamp: temp.GetCreationTimestamp().Time,
        UpdateTimestamp: extractUpdateTimestamp(annotations),
        CreatedBy: extractCreatedBy(annotations),
        UpdatedBy: extractUpdatedBy(annotations),
        ExtraFields: map[string]any{},
    }
    // Thema hates null fields for these ones
    if md.Finalizers == nil {
        md.Finalizers = []string{}
    }
    if md.Labels == nil {
        md.Labels = map[string]string{}
    }
    metadataBytes, err := json.Marshal(md)
    if err != nil {
        return err
    }
    if len(temp.Status) == 0 {
        temp.Status, err = json.Marshal(Status{})
        if err != nil {
            return err
        }
    }
    err = ThemaUnmarshalFunc(cast, ThemaObjectBytes{
        Metadata: metadataBytes,
        Spec: temp.Spec,
        Subresources: map[string][]byte{
            "status": temp.Status,
        },
    })
    if err != nil {
        return err
    }
    // Overwrite the metadata in the unmarshaled object with the one from temp (to get accurate kube metadata)
    cast.ObjectMeta = temp.ObjectMeta
    return nil
}

// Write writes JSON-encoded bytes into `writer` marshaled from `from`
func (*JSONCodec) Write(writer io.Writer, from resource.Object) error {
    // Object is already ready to be encoded as kubernetes JSON, no special behavior for write
    return json.NewEncoder(writer).Encode(from)
}

{{ range .CustomMetadataFields }}func extract{{.FieldName}}(annotations map[string]string) {{.GoType.GoType}} {
    {{ $var := (printf "annotations[\"%v\"]" .JSONName) }}
    {{ $ret := (call .GoType.GetFuncTemplate $var) }}
    {{ $ret }}
}

func set{{.FieldName}}(annotations map[string]string, {{.JSONName}} {{.GoType.GoType}}) {
    {{ $var := (printf "annotations[\"%v\"]" .JSONName) }}
    {{ $ret := (call .GoType.SetFuncTemplate .JSONName $var) }}
    {{ $ret }}
}
{{ end }}
// Interface compliance checks
var _ resource.Codec = &JSONCodec{}