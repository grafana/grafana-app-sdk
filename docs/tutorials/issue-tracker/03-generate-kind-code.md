# Generating Kind Code

Now that we have our kind and schema defined, we want to generate code from them that we can use. In the future, we'll want to re-generate this code whenever we change anything in our `kinds` directory. The SDK provides a command for this: `grafana-app-sdk generate`, but our project init also gave us a make target which will do the same thing, so you can run either. Here, I'm running the make target:
```shell
make generate
```
This command should ouput a list of all the files it writes:
```shell
$ make generate
 * Writing file pkg/generated/resource/issue/v1/issue_metadata_gen.go
 * Writing file pkg/generated/resource/issue/v1/issue_object_gen.go
 * Writing file pkg/generated/resource/issue/v1/issue_schema_gen.go
 * Writing file pkg/generated/resource/issue/v1/issue_spec_gen.go
 * Writing file pkg/generated/resource/issue/v1/issue_status_gen.go
 * Writing file plugin/src/generated/issue/v1/types.gen.ts
 * Writing file definitions/issue.issue-tracker-project.ext.grafana.com.json
```
That's a bunch of files written! Let's tree the directory to understand the structure a bit better.
```shell
$ tree .
.
├── Makefile
├── cmd
│   └── operator
├── definitions
│   └── issue.issue-tracker-project.ext.grafana.com.json
├── go.mod
├── go.sum
├── kinds
│   ├── cue.mod
│   │   └── module.cue
│   └── issue.cue
├── local
│   ├── Tiltfile
│   ├── additional
│   ├── config.yaml
│   ├── mounted-files
│   │   └── plugin
│   └── scripts
│       ├── cluster.sh
│       └── push_image.sh
├── pkg
│   └── generated
│       └── resource
│           └── issue
│               └── v1
│                   ├── issue_metadata_gen.go
│                   ├── issue_object_gen.go
│                   ├── issue_schema_gen.go
│                   ├── issue_spec_gen.go
│                   └── issue_status_gen.go
└── plugin
    └── src
        └── generated
            └── issue
                └── v1
                    └── types.gen.ts

21 directories, 16 files
```

So we can now see that all our generated go code lives in the `pkg/generated` package. Since our `target` was `"resource"`, the generated code for `issue` is in the `pkg/generated/resource` package. 
Each `resource`-target kind then lives in a package defined by the name of the kind: in our case, that is `issue`. If we created another kind in our `kinds` directory called "foo", we'd see a `pkg/generated/resource/foo` directory.

If we had a separate kind which didn't have the `apiResource` field, we'd see a `pkg/generated/models` package directory. We'll see that later, in our follow-up, where we extend on the project.

Note that the go types are in versioned packages, as by default the SDK will generate types for each version of the kind.

Note that we also have generated TypeScript in our previously-empty `plugin` directory. By convention, the Grafana plugin for your project will live in the `plugin` directory, so here we've got some TypeScript generated in `plugin/src/generated` to use when we start working on the front-end of our plugin.

## Generated Go Code

The package with the largest number of files generated by `make generate` is the `pkg/generated/resource/issue` package. 
This is also the package where all of our generated go code lives (even with multiple kinds, all generated go code will live in `pkg/generated`). 

Let's take a closer look at the list of files:
```shell
$ tree pkg/generated
pkg/generated
└── resource
    └── issue
        └── v1
            ├── issue_metadata_gen.go
            ├── issue_object_gen.go
            ├── issue_schema_gen.go
            ├── issue_spec_gen.go
            └── issue_status_gen.go

4 directories, 5 files
```

The exported go types from our kind's `v1` schema definition are `issue_metadata_gen.go`, `issue_spec_gen.go`, and `issue_status_gen.go`. You'll note that `issue_metadata_gen.go` and `issue_status_gen.go` contain types and fields which we didn't define in our schema--that's because of the joined "default" metadata and status information. If we had defined a `status` or `metadata` in our schema, those fields would _also_ be present in the generated types.

In addition to the types generated from our kind's schema, we have `issue_object_gen.go` and `issue_schema_gen.go`. `issue_object_gen.go` defines the complete object (with `spec`, `status`, and `schema` in it) in a way that satisfies the `resource.Object` interface, so that it can be used with the SDK. Likewise, `issue_schema_gen.go` defines a `resource.Schema` for this specific version of the kind which can be used in your project.

## Generated TypeScript Code

```shell
$ tree plugin
plugin
└── src
    └── generated
        └── issue_types.gen.ts

3 directories, 1 file
```

The generated TypeScript contains an interface built from our schema. TypeScript code is only generated for kinds where `frontend: true`.

### Generated Custom Resource Definitions

Finally, we have the custom resource definition file that describes our `issue` kind as a CRD, which lives in `definitions` by default. 
Note that this is a CRD of the kind, not just the schema, so the CRD will contain all schema versions in the kind. 
This can be used to set up kubernetes as our storage layer for our project.

```shell
$ tree definitions
definitions
└── issue.issue-tracker-project.ext.grafana.com.json

1 directory, 1 file
```

So now we have a bunch of generated code, but we still need a project to actually use it in. 
The SDK gives us some tooling to set up our project with boilerplate code, [so let's do that next](04-boilerplate.md).

### Prev: [Defining Our Kinds & Schemas](02-defining-our-kinds.md)
### Next: [Generating Boilerplate](04-boilerplate.md)